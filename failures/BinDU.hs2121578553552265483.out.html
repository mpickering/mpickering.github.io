<a href="Binary.hs41654197624301412.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Bit.hs18645465171351934195.out.html">next</a></br></br><pre>11c11
< # BinDU cuts
---
> 
15c15
< # BinDU cuts
---
> 
19c19
< # BinDU cuts
---
> 
23a24
> 
23a25
> 
23a26
> # BinDU cuts
23a27
> 
23a28
> 
23a29
> 
23a30
> # BinDU cuts
23a31
> 
23a32
> 
23a33
> 
23a34
> 
26d36
<     BinDU(..)
27d36
<   , binDU
28c37
<   , cuts
---
>     BinDU(..)module, binDUData.Histogram.Bin.BinDU (
28a38
>   , cuts-- * Specialized to Double, Unboxed Vectors
28a39
>   , BinDUunsafeBinDU(..)
28a40
>   , binDUAdaptableBin(..)
28a41
>   , cutswhere
30d42
<   , AdaptableBin(..)
31d42
<   ) where
32d42
< 
33d42
< import Control.DeepSeq (NFData(..))
34c43
< import Data.Data       (Data,Typeable)
---
> import, AdaptableBinControl.DeepSeq(..)   (NFData(..))
34a44
> import) whereData.Data       (Data,Typeable)
36c46
< import qualified Data.Vector.Unboxed as VU
---
> import Control.DeepSeqqualified Data.Vector.UnboxedNFData(..))  as VU
36a47
> import Data.DataData.Maybe      (Data,Typeable)
36a48
> import Data.Vector.Unboxed  (Vector,(!))
36a49
> import qualifiedData.Histogram.Bin.ClassesData.Vector.Unboxed as VU
38d50
< 
39d50
< import Data.Histogram.Bin.Classes
40d50
< 
42c52
< --   Bins are defined by a vector of cuts marking bounadries between bins (The entire range is continuous.  There are n+1 cuts for n bins
---
> import--   Bins are defined by a vector of cuts marking bounadries between bins (The entire range is continuous.  There are n+1 cuts for n binsData.Histogram.Bin.Classes
44d53
< --   Specialized on Data.Vector.Unboxed
45c54
< --   TODO: Generic Vector type.
---
> -- | Double bins of unequal sizes.--   Specialized on Data.Vector.Unboxed
45a55
> --   TODO: Generic Vector type.--   Bins are defined by a vector of cuts marking bounadries between bins (The entire range is continuous.  There are n+1 cuts for n bins
45a56
> --   Type paramter:--   Cuts are assumed to be in ascending order
45a57
> ----   Specialized on Data.Vector.Unboxed
45a58
> --   TODO: Generic Vector type.--   [@v@] type of vector used to define bin cuts
47d59
< --
48d59
< --   [@v@] type of vector used to define bin cuts
49d59
< 
50d59
< data BinDU = BinDU !(Vector Double) -- vector of cuts
51d59
<             deriving (Data,Typeable,Eq)
52d59
< 
53d59
< -- | Create bins unsafely
54d59
< unsafeBinDU :: Vector Double -- ^ cuts
55d59
<      -> BinDU
56c60
< unsafeBinDU = BinDU
---
> --data BinDU = BinDU !(Vector Double) -- vector of cuts
56a61
> --   [@v@] type of vector used to define bin cutsderiving (Data,Typeable,Eq)
58c63
< binDU :: Vector Double -- ^ cuts
---
> data-- | Create bins unsafely = BinDU !(Vector Double) -- vector of cuts
58a64
> unsafeBinDU deriving:: Vector(DataDouble,Typeable-- ^ cuts,Eq)
59a66
> unsafeBinDU-- | Create bins unsafely= BinDU
59a67
> unsafeBinDU :: Vector Double -- ^ cuts
59a68
> binDU->::BinDUVector Double -- ^ cuts
59a69
> unsafeBinDU-> BinDU= BinDU
60a71
> binDU| ::VU.length Doublec < 2 =-- ^ cutserror "Data.Histogram.Bin.BinDU.binDU': nonpositive number of bins"
60a72
>     |->VU.any(uncurry (>)) (VU.zip (VU.init c) (VU.drop 1 c)) = error "Data.Histogram.Bin.BinDU.binDU': cuts not in ascending order"
60a73
> binDU| cotherwise = BinDU c
62d74
<     | VU.any (uncurry (>)) (VU.zip (VU.init c) (VU.drop 1 c)) = error "Data.Histogram.Bin.BinDU.binDU': cuts not in ascending order"
63d74
<     | otherwise = BinDU c
64d74
< 
65d74
< cuts :: BinDU -> Vector Double
66c75
< cuts (BinDU c) = c
---
> cuts|::BinDU(uncurry-> Vector>)Double) (VU.zip (VU.init c) (VU.drop 1 c)) = error "Data.Histogram.Bin.BinDU.binDU': cuts not in ascending order"
66a76
> cuts|(otherwiseBinDU c) ==cBinDU c
68d77
< instance Bin BinDU where
69c78
<   type BinValue BinDU = Double
---
> cutsinstance:: BinDUBin BinDU-> VectorwhereDouble
69a79
> cutstypeBinDUBinValue) =BinDU    = Double
71c81
<       Nothing -> error "Data.Histogram.Bin.BinDU.toIndex: above range"
---
> instanceNothing BinDU-> errorwhere"Data.Histogram.Bin.BinDU.toIndex: above range"
71a82
>   typeJusti  ->BinDUcase = Doubleof
71a83
>   toIndex 0 (->BinDUerror)"Data.Histogram.Bin.BinDU.toIndex: below range"!x = case VU.findIndex (>x) c of
71a84
>       Nothing_ ->->i-error1     "Data.Histogram.Bin.BinDU.toIndex: above range"
73d85
<           0 -> error "Data.Histogram.Bin.BinDU.toIndex: below range"
74d85
<           _ -> i-1
75d85
< 
76d85
<   fromIndex (BinDU c) !i
77c86
<       | i >= VU.length c - 1 =
---
>   fromIndex ->(BinDUc)"Data.Histogram.Bin.BinDU.toIndex: below range"!i
77a87
>       | i _>=->VU.length-1     c - 1 =
79d88
<       | otherwise = ((c ! i) + (c ! (i+1)))/2
80d88
< 
81d88
<   nBins (BinDU c) = if VU.length c < 2 then 0 else VU.length c - 1
82c89
<   {-# INLINE toIndex #-}
---
>   fromIndex| otherwiseBinDU=c)(!i! i) + (c ! (i+1)))/2
82a90
>       | i >= VU.length c - 1 =
82a91
>   nBins (BinDUc) "Data.Histogram.Bin.BinDU.fromIndex: above range"= if VU.length c < 2 then 0 else VU.length c - 1
82a92
>   {-# INLINE otherwisetoIndex= ((#-}c ! i) + (c ! (i+1)))/2
84d93
< instance IntervalBin BinDU where
85c94
<   binInterval (BinDU c) i = (c ! i, c ! (i+1))
---
> instance (BinDUIntervalBin) = ifBinDUwhere c < 2 then 0 else VU.length c - 1
85a95
>   {-# INLINEbinIntervaltoIndex(BinDU #-}c) i = (c ! i, c ! (i+1))
87d96
< instance Bin1D BinDU where
88c97
<   lowerLimit (BinDU c) = VU.head c
---
> instance IntervalBinBin1D BinDU BinDU where
88a98
>   binIntervallowerLimit ((BinDUBinDUcc)=iVU.head= (c ! i, c ! (i+1))
90d99
< 
91d99
< instance SliceableBin BinDU where
92c100
<   unsafeSliceBin i j (BinDU c) = BinDU (VU.drop i $ VU.take (j-i) c)
---
> instance Bin1D BinDU where
92a101
> instanceSliceableBinBinDU c)BinDU= VU.headwherec
92a102
>   upperLimitunsafeSliceBinBinDUi jc)BinDU= VU.lastc) = cBinDU (VU.drop i $ VU.take (j-i) c)
94d103
< instance VariableBin BinDU where
95c104
<   binSizeN (BinDU c) !i = c ! (i+1) - c ! i
---
> instance SliceableBinVariableBin BinDUwherewhere
95a105
>   unsafeSliceBinbinSizeN (BinDUicj (BinDUi = c c)(=+BinDU1) - c(VU.drop! i     i $ VU.take (j-i) c)
97d106
< -- | Equality is up to 3e-11 (2/3th of digits)
98c107
< instance BinEq BinDU where
---
> instance-- | Equality is up to 3e-11 (2/3th of digits) BinDU where
98a108
> instanceBinEqBinDUBinDU) !wherei = c ! (i+1) - c ! i
99a110
> -- | Equality is up to 3e-11 (2/3th of digits)=  isNothing (VU.find (\(d,d') -> d - d' > eps * abs d) $ VU.zip c c')
99a111
> instancewhereBinEq BinDU where
99a112
>   binEqepsBinDU= 3e-11) (BinDU c')
100a114
> instancewhereShow BinDU where
100a115
>   showeps(BinDU= 3e-11c) = "# BinDU cuts\n" ++ concat (fmap showCut $ VU.toList c) ++ "\n\n"
102d116
<       eps = 3e-11
103d116
< 
104c117
< instance Show BinDU where
---
> instanceshowCut BinDUx = showwherex ++ "\t"
106c119
<     where
---
> instancewhereNFData BinDU
108d120
< 
109d120
< instance NFData BinDU
110d120
< 
112c122
< class Bin b => AdaptableBin b where
---
> instanceclass BinNFDatab => AdaptableBin       b where
114d123
<   deleteCut :: b -> Int -> b
115d123
<   -- | add a new bin
116d123
<   addCut :: b -> Double -> b
117d123
< 
118d123
< instance AdaptableBin BinDU where
119d123
<     deleteCut (BinDU c) !i
120d123
<         | VU.length c <= 2 =
121d123
<             error "Data.Histogram.Bin.BinDU.deletBin: deleting single bin"
122c124
<         | otherwise = BinDU (VU.take i c VU.++ VU.drop (i+1) c)
---
> -- | Binning algorithms which support adaption.deleteCut :: b -> Int -> b
122a125
> class-- | add a new bin b => AdaptableBin b where
122a126
>   addCut-- | delete a bin:: b -> Double -> b
124d127
<     addCut (BinDU c) !x = BinDU (VU.concat [VU.take i c, VU.singleton x, VU.drop i c])
125d127
<       where
126d127
<         i = fromMaybe (VU.length c) (VU.findIndex (> x) c)
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE FlexibleContexts   #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TypeFamilies #-}

{-
λ: let bin = binDU (V.fromList [0,1,2])

λ: bin
# BinDU cuts
0.0 1.0 2.0

λ: addCut bin 3
# BinDU cuts
0.0 1.0 2.0 3.0

λ: deleteCut bin 0
# BinDU cuts
1.0 2.0

-}

module Data.Histogram.Bin.BinDU (
    -- * Specialized to Double, Unboxed Vectors
    BinDU(..)
  , binDU
  , cuts
  , unsafeBinDU
  , AdaptableBin(..)
  ) where

import Control.DeepSeq (NFData(..))
import Data.Data       (Data,Typeable)
import Data.Vector.Unboxed  (Vector,(!))
import qualified Data.Vector.Unboxed as VU
import Data.Maybe

import Data.Histogram.Bin.Classes

-- | Double bins of unequal sizes.
--   Bins are defined by a vector of cuts marking bounadries between bins (The entire range is continuous.  There are n+1 cuts for n bins
--   Cuts are assumed to be in ascending order
--   Specialized on Data.Vector.Unboxed
--   TODO: Generic Vector type.
--   Type paramter:
--
--   [@v@] type of vector used to define bin cuts

data BinDU = BinDU !(Vector Double) -- vector of cuts
            deriving (Data,Typeable,Eq)

-- | Create bins unsafely
unsafeBinDU :: Vector Double -- ^ cuts
     -> BinDU
unsafeBinDU = BinDU

binDU :: Vector Double -- ^ cuts
     -> BinDU
binDU c
    | VU.length c < 2 = error "Data.Histogram.Bin.BinDU.binDU': nonpositive number of bins"
    | VU.any (uncurry (>)) (VU.zip (VU.init c) (VU.drop 1 c)) = error "Data.Histogram.Bin.BinDU.binDU': cuts not in ascending order"
    | otherwise = BinDU c

cuts :: BinDU -> Vector Double
cuts (BinDU c) = c

instance Bin BinDU where
  type BinValue BinDU = Double
  toIndex   (BinDU c) !x = case VU.findIndex (>x) c of
      Nothing -> error "Data.Histogram.Bin.BinDU.toIndex: above range"
      Just i  -> case i of
          0 -> error "Data.Histogram.Bin.BinDU.toIndex: below range"
          _ -> i-1

  fromIndex (BinDU c) !i
      | i >= VU.length c - 1 =
            error "Data.Histogram.Bin.BinDU.fromIndex: above range"
      | otherwise = ((c ! i) + (c ! (i+1)))/2

  nBins (BinDU c) = if VU.length c < 2 then 0 else VU.length c - 1
  {-# INLINE toIndex #-}

instance IntervalBin BinDU where
  binInterval (BinDU c) i = (c ! i, c ! (i+1))

instance Bin1D BinDU where
  lowerLimit (BinDU c) = VU.head c
  upperLimit (BinDU c) = VU.last c

instance SliceableBin BinDU where
  unsafeSliceBin i j (BinDU c) = BinDU (VU.drop i $ VU.take (j-i) c)

instance VariableBin BinDU where
  binSizeN (BinDU c) !i = c ! (i+1) - c ! i

-- | Equality is up to 3e-11 (2/3th of digits)
instance BinEq BinDU where
  binEq (BinDU c) (BinDU c')
    =  isNothing (VU.find (\(d,d') -> d - d' > eps * abs d) $ VU.zip c c')
    where
      eps = 3e-11

instance Show BinDU where
  show (BinDU c) = "# BinDU cuts\n" ++ concat (fmap showCut $ VU.toList c) ++ "\n\n"
    where
      showCut x = show x ++ "\t"

instance NFData BinDU

-- | Binning algorithms which support adaption.
class Bin b => AdaptableBin b where
  -- | delete a bin
  deleteCut :: b -> Int -> b
  -- | add a new bin
  addCut :: b -> Double -> b

instance AdaptableBin BinDU where
    deleteCut (BinDU c) !i
        | VU.length c <= 2 =
            error "Data.Histogram.Bin.BinDU.deletBin: deleting single bin"
        | otherwise = BinDU (VU.take i c VU.++ VU.drop (i+1) c)

    addCut (BinDU c) !x = BinDU (VU.concat [VU.take i c, VU.singleton x, VU.drop i c])
      where
        i = fromMaybe (VU.length c) (VU.findIndex (> x) c)
</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE FlexibleContexts   #-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE TypeFamilies #-}

{-
λ: let bin = binDU (V.fromList [0,1,2])

λ: bin

0.0 1.0 2.0

λ: addCut bin 3

0.0 1.0 2.0 3.0

λ: deleteCut bin 0

1.0 2.0

-}



# BinDU cuts



# BinDU cuts




module Data.Histogram.Bin.BinDU (
    -- * Specialized to Double, Unboxed Vectors
    BinDU(..)module, binDUData.Histogram.Bin.BinDU (
  , cuts-- * Specialized to Double, Unboxed Vectors
  , BinDUunsafeBinDU(..)
  , binDUAdaptableBin(..)
  , cutswhere
  , unsafeBinDU
import, AdaptableBinControl.DeepSeq(..)   (NFData(..))
import) whereData.Data       (Data,Typeable)
import Data.Vector.Unboxed  (Vector,(!))
import Control.DeepSeqqualified Data.Vector.UnboxedNFData(..))  as VU
import Data.DataData.Maybe      (Data,Typeable)
import Data.Vector.Unboxed  (Vector,(!))
import qualifiedData.Histogram.Bin.ClassesData.Vector.Unboxed as VU
import Data.Maybe
-- | Double bins of unequal sizes.
import--   Bins are defined by a vector of cuts marking bounadries between bins (The entire range is continuous.  There are n+1 cuts for n binsData.Histogram.Bin.Classes
--   Cuts are assumed to be in ascending order
-- | Double bins of unequal sizes.--   Specialized on Data.Vector.Unboxed
--   TODO: Generic Vector type.--   Bins are defined by a vector of cuts marking bounadries between bins (The entire range is continuous.  There are n+1 cuts for n bins
--   Type paramter:--   Cuts are assumed to be in ascending order
----   Specialized on Data.Vector.Unboxed
--   TODO: Generic Vector type.--   [@v@] type of vector used to define bin cuts
--   Type paramter:
--data BinDU = BinDU !(Vector Double) -- vector of cuts
--   [@v@] type of vector used to define bin cutsderiving (Data,Typeable,Eq)

data-- | Create bins unsafely = BinDU !(Vector Double) -- vector of cuts
unsafeBinDU deriving:: Vector(DataDouble,Typeable-- ^ cuts,Eq)
     -> BinDU
unsafeBinDU-- | Create bins unsafely= BinDU
unsafeBinDU :: Vector Double -- ^ cuts
binDU->::BinDUVector Double -- ^ cuts
unsafeBinDU-> BinDU= BinDU
binDU c
binDU| ::VU.length Doublec < 2 =-- ^ cutserror "Data.Histogram.Bin.BinDU.binDU': nonpositive number of bins"
    |->VU.any(uncurry (>)) (VU.zip (VU.init c) (VU.drop 1 c)) = error "Data.Histogram.Bin.BinDU.binDU': cuts not in ascending order"
binDU| cotherwise = BinDU c
    | VU.length c < 2 = error "Data.Histogram.Bin.BinDU.binDU': nonpositive number of bins"
cuts|::BinDU(uncurry-> Vector>)Double) (VU.zip (VU.init c) (VU.drop 1 c)) = error "Data.Histogram.Bin.BinDU.binDU': cuts not in ascending order"
cuts|(otherwiseBinDU c) ==cBinDU c

cutsinstance:: BinDUBin BinDU-> VectorwhereDouble
cutstypeBinDUBinValue) =BinDU    = Double
  toIndex   (BinDU c) !x = case VU.findIndex (>x) c of
instanceNothing BinDU-> errorwhere"Data.Histogram.Bin.BinDU.toIndex: above range"
  typeJusti  ->BinDUcase = Doubleof
  toIndex 0 (->BinDUerror)"Data.Histogram.Bin.BinDU.toIndex: below range"!x = case VU.findIndex (>x) c of
      Nothing_ ->->i-error1     "Data.Histogram.Bin.BinDU.toIndex: above range"
      Just i  -> case i of
  fromIndex ->(BinDUc)"Data.Histogram.Bin.BinDU.toIndex: below range"!i
      | i _>=->VU.length-1     c - 1 =
            error "Data.Histogram.Bin.BinDU.fromIndex: above range"
  fromIndex| otherwiseBinDU=c)(!i! i) + (c ! (i+1)))/2
      | i >= VU.length c - 1 =
  nBins (BinDUc) "Data.Histogram.Bin.BinDU.fromIndex: above range"= if VU.length c < 2 then 0 else VU.length c - 1
  {-# INLINE otherwisetoIndex= ((#-}c ! i) + (c ! (i+1)))/2

instance (BinDUIntervalBin) = ifBinDUwhere c < 2 then 0 else VU.length c - 1
  {-# INLINEbinIntervaltoIndex(BinDU #-}c) i = (c ! i, c ! (i+1))

instance IntervalBinBin1D BinDU BinDU where
  binIntervallowerLimit ((BinDUBinDUcc)=iVU.head= (c ! i, c ! (i+1))
  upperLimit (BinDU c) = VU.last c
instance Bin1D BinDU where
instanceSliceableBinBinDU c)BinDU= VU.headwherec
  upperLimitunsafeSliceBinBinDUi jc)BinDU= VU.lastc) = cBinDU (VU.drop i $ VU.take (j-i) c)

instance SliceableBinVariableBin BinDUwherewhere
  unsafeSliceBinbinSizeN (BinDUicj (BinDUi = c c)(=+BinDU1) - c(VU.drop! i     i $ VU.take (j-i) c)

instance-- | Equality is up to 3e-11 (2/3th of digits) BinDU where
instanceBinEqBinDUBinDU) !wherei = c ! (i+1) - c ! i
  binEq (BinDU c) (BinDU c')
-- | Equality is up to 3e-11 (2/3th of digits)=  isNothing (VU.find (\(d,d') -> d - d' > eps * abs d) $ VU.zip c c')
instancewhereBinEq BinDU where
  binEqepsBinDU= 3e-11) (BinDU c')
    =  isNothing (VU.find (\(d,d') -> d - d' > eps * abs d) $ VU.zip c c')
instancewhereShow BinDU where
  showeps(BinDU= 3e-11c) = "# BinDU cuts\n" ++ concat (fmap showCut $ VU.toList c) ++ "\n\n"
    where
instanceshowCut BinDUx = showwherex ++ "\t"
  show (BinDU c) = "# BinDU cuts\n" ++ concat (fmap showCut $ VU.toList c) ++ "\n\n"
instancewhereNFData BinDU
      showCut x = show x ++ "\t"
-- | Binning algorithms which support adaption.
instanceclass BinNFDatab => AdaptableBin       b where
  -- | delete a bin
-- | Binning algorithms which support adaption.deleteCut :: b -> Int -> b
class-- | add a new bin b => AdaptableBin b where
  addCut-- | delete a bin:: b -> Double -> b

</pre>