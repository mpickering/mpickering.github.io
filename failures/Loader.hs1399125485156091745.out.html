<a href="Load.hs16814625331603481258.out.html">prev</a></br><a href="failures.html">home</a></br><a href="LoadSaveController.hs750597385971307217.out.html">next</a></br></br><pre>22c22
< todoName ‚à∑ Todo ‚Üí String
---
> todoName :: Todo -> String
25d24
< getDepends ‚à∑ TodoMap ‚Üí TodoItem ‚Üí [Todo]
26c25
< getDepends m item = catMaybes [M.lookup name m | name ‚Üê depends item]
---
> getDepends :: TodoMap -> TodoItem -> [Todo]
26a26
> getDepends m item = catMaybes [M.lookup name m | name <- depends item]
28c28
< normalize ‚à∑ TodoMap ‚Üí Todo ‚Üí Todo
---
> normalize :: TodoMap -> Todo -> Todo
31c31
<     item ‚à∑ TodoItem
---
>     item :: TodoItem
34c34
<     item' ‚à∑ TodoItem
---
>     item' :: TodoItem
37c37
<     subTodos ‚à∑ [Todo]
---
>     subTodos :: [Todo]
40c40
<     deps ‚à∑ [Todo]
---
>     deps :: [Todo]
43c43
< normalizeList ‚à∑ TodoMap ‚Üí [Todo] ‚Üí [Todo]
---
> normalizeList :: TodoMap -> [Todo] -> [Todo]
47c47
< readFile' ‚à∑ FilePath ‚Üí IO String
---
> readFile' :: FilePath -> IO String
52d51
< loadFile ‚à∑ BaseConfig
53d51
<          ‚Üí DateTime       -- ^ Current date/time
54d51
<          ‚Üí FilePath       -- ^ Path to file
55c52
<          ‚Üí IO [TodoItem]
---
> loadFile :: BaseConfig
55a53
>          -> DateTime       -- ^ Current date/time
55a54
>          -> FilePath       -- ^ Path to file
55a55
>          -> IO [TodoItem]
58d57
<     Nothing ‚Üí do
59c58
<         text ‚Üê readFile' path
---
>     Nothing -> do
59a59
>         text <- readFile' path
61d60
<     Just p  ‚Üí do
62c61
<         text ‚Üê readFile' path
---
>     Just p  -> do
62a62
>         text <- readFile' path
66c66
< (~-) ‚à∑  TodoItem ‚Üí ‚Ñ§ ‚Üí TodoItem
---
> (~-) ::  TodoItem -> ‚Ñ§ -> TodoItem
70c70
< (~+) ‚à∑  TodoItem ‚Üí ‚Ñ§ ‚Üí TodoItem
---
> (~+) ::  TodoItem -> ‚Ñ§ -> TodoItem
74c74
< iszero ‚à∑  TodoItem ‚Üí ùîπ
---
> iszero ::  TodoItem -> ùîπ
77c77
< group' ‚à∑  [TodoItem] ‚Üí [[TodoItem]]
---
> group' ::  [TodoItem] -> [[TodoItem]]
82c82
< mkTodo ‚à∑ [TodoItem] ‚Üí [Todo]
---
> mkTodo :: [TodoItem] -> [Todo]
85c85
< mkTodo' ‚à∑ [TodoItem] ‚Üí Todo
---
> mkTodo' :: [TodoItem] -> Todo
91c91
< consTodoMap ‚à∑ [Todo] ‚Üí TodoMap
---
> consTodoMap :: [Todo] -> TodoMap
94c94
<     cons1 ‚à∑ Int ‚Üí [Todo] ‚Üí [(String,Todo)]
---
>     cons1 :: Int -> [Todo] -> [(String,Todo)]
96d95
<     cons1 max trees = [(todoName todo, todo) | todo ‚Üê trees] ‚ß∫ cons1 (max-1) (children trees)
97c96
<     children ‚à∑ [Todo] ‚Üí [Todo]
---
>     cons1 max trees = [(todoName todo, todo) | todo <- trees] ‚ß∫ cons1 (max-1) (children trees)
97a97
>     children :: [Todo] -> [Todo]
100c100
< stitchTodos ‚à∑ [TodoItem] ‚Üí [Todo]
---
> stitchTodos :: [TodoItem] -> [Todo]
107c107
< allTags ‚à∑ [Todo] ‚Üí [String]
---
> allTags :: [Todo] -> [String]
113c113
< allStatuses ‚à∑ [Todo] ‚Üí [String]
---
> allStatuses :: [Todo] -> [String]
118c118
< grepBy ‚à∑ (TodoItem ‚Üí ùîπ) ‚Üí [Todo] ‚Üí [Todo]
---
> grepBy :: (TodoItem -> ùîπ) -> [Todo] -> [Todo]
121c121
<     grep ‚à∑ Todo ‚Üí [Todo]
---
>     grep :: Todo -> [Todo]
124c124
<     test ‚à∑ Todo ‚Üí [Todo]
---
>     test :: Todo -> [Todo]
129d128
< grepByTag ‚à∑ String ‚Üí [Todo] ‚Üí [Todo]
130c129
< grepByTag tag todos = grepBy (\item ‚Üí tag ‚àà itemTags item) todos
---
> grepByTag :: String -> [Todo] -> [Todo]
130a130
> grepByTag tag todos = grepBy (\item -> tag ‚àà itemTags item) todos
132d131
< grepByStatus ‚à∑ String ‚Üí [Todo] ‚Üí [Todo]
133c132
< grepByStatus st todos = grepBy (\item ‚Üí st == itemStatus item) todos
---
> grepByStatus :: String -> [Todo] -> [Todo]
133a133
> grepByStatus st todos = grepBy (\item -> st == itemStatus item) todos
135c135
< tagTodo ‚à∑ String ‚Üí [Todo] ‚Üí Todo
---
> tagTodo :: String -> [Todo] -> Todo
153c153
< groupByTag' ‚à∑ [Todo] ‚Üí [Todo]
---
> groupByTag' :: [Todo] -> [Todo]
155c155
<   map (\t ‚Üí tagTodo t todos) (allTags todos) ‚ß∫ todos
---
>   map (\t -> tagTodo t todos) (allTags todos) ‚ß∫ todos
157c157
< statusTodo ‚à∑ String ‚Üí [Todo] ‚Üí Todo
---
> statusTodo :: String -> [Todo] -> Todo
175c175
< groupByStatus' ‚à∑ [Todo] ‚Üí [Todo]
---
> groupByStatus' :: [Todo] -> [Todo]
177c177
<   map (\s ‚Üí statusTodo s todos) (allStatuses todos) ‚ß∫ todos
---
>   map (\s -> statusTodo s todos) (allStatuses todos) ‚ß∫ todos
179c179
< dirname ‚à∑ FilePath ‚Üí FilePath
---
> dirname :: FilePath -> FilePath
182d181
<     [] ‚Üí []
183c182
<     dir ‚Üí takeFileName (init dir)
---
>     [] -> []
183a183
>     dir -> takeFileName (init dir)
185c185
< fileTodo ‚à∑ FilePath ‚Üí TodoItem
---
> fileTodo :: FilePath -> TodoItem
201c201
< todosGroup ‚à∑ FilePath ‚Üí [TodoItem] -> [TodoItem]
---
> todosGroup :: FilePath -> [TodoItem] -> [TodoItem]
207c207
< changeTopStatus ‚à∑ Maybe String ‚Üí [Todo] ‚Üí [Todo]
---
> changeTopStatus :: Maybe String -> [Todo] -> [Todo]
214d213
< loadTodo ‚à∑ BaseConfig
215d213
<          ‚Üí DateTime      -- ^ Current date/time
216d213
<          ‚Üí [FilePath]    -- ^ List of files
217c214
<          ‚Üí IO [Todo]
---
> loadTodo :: BaseConfig
217a215
>          -> DateTime      -- ^ Current date/time
217a216
>          -> [FilePath]    -- ^ List of files
217a217
>          -> IO [Todo]
222c222
<     tss ‚Üê forM paths $ \path ‚Üí grp path `fmap` loadFile conf date path
---
>     tss <- forM paths $ \path -> grp path `fmap` loadFile conf date path
231a232
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, PatternGuards #-}
-- | Read TODOs from files and construct corresponding ADTs.
module Todos.Loader
  (loadTodo)
  where

import Prelude hiding (putStrLn,readFile,getContents,print)
import Prelude.Unicode
import Control.Monad (forM)
import qualified Data.Map as M
import System.FilePath
import Data.Maybe
import Data.Tree
import Data.List (nub, sort)
import Data.Dates

import Todos.IO
import Todos.Types
import Todos.Config
import Todos.Parser

todoName ‚à∑ Todo ‚Üí String
todoName todo = itemName $ rootLabel todo

getDepends ‚à∑ TodoMap ‚Üí TodoItem ‚Üí [Todo]
getDepends m item = catMaybes [M.lookup name m | name ‚Üê depends item]

normalize ‚à∑ TodoMap ‚Üí Todo ‚Üí Todo
normalize m todo = Node item' ((map (normalize m) subTodos) ‚ß∫ (map (normalize m) deps))
  where
    item ‚à∑ TodoItem
    item = rootLabel todo

    item' ‚à∑ TodoItem
    item' = item {depends=[]}

    subTodos ‚à∑ [Todo]
    subTodos = subForest todo

    deps ‚à∑ [Todo]
    deps = getDepends m item

normalizeList ‚à∑ TodoMap ‚Üí [Todo] ‚Üí [Todo]
normalizeList m todos = map (normalize m) todos

-- | Almost same that readFile, but also works for special "-" file (stdin)
readFile' ‚à∑ FilePath ‚Üí IO String
readFile' "-"  = getContents
readFile' file = readFile file

-- | Load items from given file
loadFile ‚à∑ BaseConfig
         ‚Üí DateTime       -- ^ Current date/time
         ‚Üí FilePath       -- ^ Path to file
         ‚Üí IO [TodoItem]
loadFile conf year path =
  case prefix conf of
    Nothing ‚Üí do
        text ‚Üê readFile' path
        return $ parsePlain conf year path text
    Just p  ‚Üí do
        text ‚Üê readFile' path
        return $ parseAlternate conf 2 p year path text

-- | Decrease item level
(~-) ‚à∑  TodoItem ‚Üí ‚Ñ§ ‚Üí TodoItem
i@(Item {itemLevel=n}) ~- k = i {itemLevel=n-k}

-- | Increase item level
(~+) ‚à∑  TodoItem ‚Üí ‚Ñ§ ‚Üí TodoItem
i@(Item {itemLevel=n}) ~+ k = i {itemLevel=n+k}

-- | Check if item level is 0
iszero ‚à∑  TodoItem ‚Üí ùîπ
iszero item = (itemLevel item)==0

group' ‚à∑  [TodoItem] ‚Üí [[TodoItem]]
group' [] = []
group' (x:xs) = let (one,other) = break iszero xs
                in (x:one):group' other

mkTodo ‚à∑ [TodoItem] ‚Üí [Todo]
mkTodo = (map mkTodo') ‚àò group'

mkTodo' ‚à∑ [TodoItem] ‚Üí Todo
mkTodo' [] = error "Internal error: mkTodo' does not sense for empty list!"
mkTodo' (x:xs) = Node x other
    where other = mkTodo $ map (~-lvl) xs
          lvl = itemLevel (head xs)

consTodoMap ‚à∑ [Todo] ‚Üí TodoMap
consTodoMap todos = M.fromList (cons1 100 todos)
  where
    cons1 ‚à∑ Int ‚Üí [Todo] ‚Üí [(String,Todo)]
    cons1 0 _ = []
    cons1 max trees = [(todoName todo, todo) | todo ‚Üê trees] ‚ß∫ cons1 (max-1) (children trees)
    children ‚à∑ [Todo] ‚Üí [Todo]
    children trees = concatMap subForest trees

stitchTodos ‚à∑ [TodoItem] ‚Üí [Todo]
stitchTodos items =
  let m = consTodoMap t
      t = mkTodo items
  in  normalizeList m t

-- | Get all (different) tags from Todo list
allTags ‚à∑ [Todo] ‚Üí [String]
allTags todos = nub $ sort $ concatMap getTags todos
  where
    getTags (Node item children) = itemTags item ‚ß∫ concatMap getTags children

-- | Get all (different) statuses from Todo list
allStatuses ‚à∑ [Todo] ‚Üí [String]
allStatuses todos = nub $ sort $ concatMap getStatus todos
  where
    getStatus (Node item children) = itemStatus item: concatMap getStatus children

grepBy ‚à∑ (TodoItem ‚Üí ùîπ) ‚Üí [Todo] ‚Üí [Todo]
grepBy cond todos = concatMap grep todos
  where
    grep ‚à∑ Todo ‚Üí [Todo]
    grep n@(Node _ children) = test n ‚ß∫ concatMap grep children

    test ‚à∑ Todo ‚Üí [Todo]
    test n@(Node item _)
      | cond item = [n]
      | otherwise = []

grepByTag ‚à∑ String ‚Üí [Todo] ‚Üí [Todo]
grepByTag tag todos = grepBy (\item ‚Üí tag ‚àà itemTags item) todos

grepByStatus ‚à∑ String ‚Üí [Todo] ‚Üí [Todo]
grepByStatus st todos = grepBy (\item ‚Üí st == itemStatus item) todos

tagTodo ‚à∑ String ‚Üí [Todo] ‚Üí Todo
tagTodo tag todos = Node item $ grepByTag tag todos
  where
    item = Item {
      itemLevel = 0,
      itemPrefix = "",
      itemName = tag,
      itemTags = ["TAG"],
      depends = [],
      itemStatus = ":",
      itemDescr = "",
      startDate = Nothing,
      endDate = Nothing,
      deadline = Nothing,
      fileName = "(no file)",
      lineNr = 0,
      itemNumber = 0}

groupByTag' ‚à∑ [Todo] ‚Üí [Todo]
groupByTag' todos =
  map (\t ‚Üí tagTodo t todos) (allTags todos) ‚ß∫ todos

statusTodo ‚à∑ String ‚Üí [Todo] ‚Üí Todo
statusTodo st todos = Node item $ grepByStatus st todos
  where
    item = Item {
      itemLevel = 0,
      itemPrefix = "",
      itemName = st,
      itemTags = ["STATUS"],
      depends = [],
      itemStatus = ":",
      itemDescr = "",
      startDate = Nothing,
      endDate = Nothing,
      deadline = Nothing,
      fileName = "(no file)",
      lineNr = 0,
      itemNumber = 0}

groupByStatus' ‚à∑ [Todo] ‚Üí [Todo]
groupByStatus' todos =
  map (\s ‚Üí statusTodo s todos) (allStatuses todos) ‚ß∫ todos

dirname ‚à∑ FilePath ‚Üí FilePath
dirname path =
  case dropFileName path of
    [] ‚Üí []
    dir ‚Üí takeFileName (init dir)

fileTodo ‚à∑ FilePath ‚Üí TodoItem
fileTodo path = Item {
  itemLevel = 0,
  itemPrefix = "",
  itemName = takeFileName path,
  itemTags = [dirname path],
  depends = [],
  itemStatus = ":",
  itemDescr = path,
  startDate = Nothing,
  endDate = Nothing,
  deadline = Nothing,
  fileName = path,
  lineNr = 0,
  itemNumber = 0}

todosGroup ‚à∑ FilePath ‚Üí [TodoItem] -> [TodoItem]
todosGroup path items =
  if null items
    then []
    else fileTodo path: map (~+ 1) items

changeTopStatus ‚à∑ Maybe String ‚Üí [Todo] ‚Üí [Todo]
changeTopStatus Nothing   todos = todos
changeTopStatus (Just st) todos = map setStatus todos
  where
    setStatus (Node item children) = Node (item {itemStatus = st}) children

-- | Load list of TODO trees from files
loadTodo ‚à∑ BaseConfig
         ‚Üí DateTime      -- ^ Current date/time
         ‚Üí [FilePath]    -- ^ List of files
         ‚Üí IO [Todo]
loadTodo conf date paths = do
    let grp = if groupByFile conf
                then todosGroup
                else const id
    tss ‚Üê forM paths $ \path ‚Üí grp path `fmap` loadFile conf date path
    let todos = stitchTodos (concat tss)
        byTag = if groupByTag conf
                  then groupByTag' todos
                  else todos
        byStatus = if groupByStatus conf
                     then groupByStatus' byTag
                     else byTag
    return $ changeTopStatus (topStatus conf) byStatus

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, PatternGuards #-}
-- | Read TODOs from files and construct corresponding ADTs.
module Todos.Loader
  (loadTodo)
  where

import Prelude hiding (putStrLn,readFile,getContents,print)
import Prelude.Unicode
import Control.Monad (forM)
import qualified Data.Map as M
import System.FilePath
import Data.Maybe
import Data.Tree
import Data.List (nub, sort)
import Data.Dates

import Todos.IO
import Todos.Types
import Todos.Config
import Todos.Parser

todoName :: Todo -> String
todoName todo = itemName $ rootLabel todo

getDepends :: TodoMap -> TodoItem -> [Todo]
getDepends m item = catMaybes [M.lookup name m | name <- depends item]

normalize :: TodoMap -> Todo -> Todo
normalize m todo = Node item' ((map (normalize m) subTodos) ‚ß∫ (map (normalize m) deps))
  where
    item :: TodoItem
    item = rootLabel todo

    item' :: TodoItem
    item' = item {depends=[]}

    subTodos :: [Todo]
    subTodos = subForest todo

    deps :: [Todo]
    deps = getDepends m item

normalizeList :: TodoMap -> [Todo] -> [Todo]
normalizeList m todos = map (normalize m) todos

-- | Almost same that readFile, but also works for special "-" file (stdin)
readFile' :: FilePath -> IO String
readFile' "-"  = getContents
readFile' file = readFile file

-- | Load items from given file
loadFile :: BaseConfig
         -> DateTime       -- ^ Current date/time
         -> FilePath       -- ^ Path to file
         -> IO [TodoItem]
loadFile conf year path =
  case prefix conf of
    Nothing -> do
        text <- readFile' path
        return $ parsePlain conf year path text
    Just p  -> do
        text <- readFile' path
        return $ parseAlternate conf 2 p year path text

-- | Decrease item level
(~-) ::  TodoItem -> ‚Ñ§ -> TodoItem
i@(Item {itemLevel=n}) ~- k = i {itemLevel=n-k}

-- | Increase item level
(~+) ::  TodoItem -> ‚Ñ§ -> TodoItem
i@(Item {itemLevel=n}) ~+ k = i {itemLevel=n+k}

-- | Check if item level is 0
iszero ::  TodoItem -> ùîπ
iszero item = (itemLevel item)==0

group' ::  [TodoItem] -> [[TodoItem]]
group' [] = []
group' (x:xs) = let (one,other) = break iszero xs
                in (x:one):group' other

mkTodo :: [TodoItem] -> [Todo]
mkTodo = (map mkTodo') ‚àò group'

mkTodo' :: [TodoItem] -> Todo
mkTodo' [] = error "Internal error: mkTodo' does not sense for empty list!"
mkTodo' (x:xs) = Node x other
    where other = mkTodo $ map (~-lvl) xs
          lvl = itemLevel (head xs)

consTodoMap :: [Todo] -> TodoMap
consTodoMap todos = M.fromList (cons1 100 todos)
  where
    cons1 :: Int -> [Todo] -> [(String,Todo)]
    cons1 0 _ = []
    cons1 max trees = [(todoName todo, todo) | todo <- trees] ‚ß∫ cons1 (max-1) (children trees)
    children :: [Todo] -> [Todo]
    children trees = concatMap subForest trees

stitchTodos :: [TodoItem] -> [Todo]
stitchTodos items =
  let m = consTodoMap t
      t = mkTodo items
  in  normalizeList m t

-- | Get all (different) tags from Todo list
allTags :: [Todo] -> [String]
allTags todos = nub $ sort $ concatMap getTags todos
  where
    getTags (Node item children) = itemTags item ‚ß∫ concatMap getTags children

-- | Get all (different) statuses from Todo list
allStatuses :: [Todo] -> [String]
allStatuses todos = nub $ sort $ concatMap getStatus todos
  where
    getStatus (Node item children) = itemStatus item: concatMap getStatus children

grepBy :: (TodoItem -> ùîπ) -> [Todo] -> [Todo]
grepBy cond todos = concatMap grep todos
  where
    grep :: Todo -> [Todo]
    grep n@(Node _ children) = test n ‚ß∫ concatMap grep children

    test :: Todo -> [Todo]
    test n@(Node item _)
      | cond item = [n]
      | otherwise = []

grepByTag :: String -> [Todo] -> [Todo]
grepByTag tag todos = grepBy (\item -> tag ‚àà itemTags item) todos

grepByStatus :: String -> [Todo] -> [Todo]
grepByStatus st todos = grepBy (\item -> st == itemStatus item) todos

tagTodo :: String -> [Todo] -> Todo
tagTodo tag todos = Node item $ grepByTag tag todos
  where
    item = Item {
      itemLevel = 0,
      itemPrefix = "",
      itemName = tag,
      itemTags = ["TAG"],
      depends = [],
      itemStatus = ":",
      itemDescr = "",
      startDate = Nothing,
      endDate = Nothing,
      deadline = Nothing,
      fileName = "(no file)",
      lineNr = 0,
      itemNumber = 0}

groupByTag' :: [Todo] -> [Todo]
groupByTag' todos =
  map (\t -> tagTodo t todos) (allTags todos) ‚ß∫ todos

statusTodo :: String -> [Todo] -> Todo
statusTodo st todos = Node item $ grepByStatus st todos
  where
    item = Item {
      itemLevel = 0,
      itemPrefix = "",
      itemName = st,
      itemTags = ["STATUS"],
      depends = [],
      itemStatus = ":",
      itemDescr = "",
      startDate = Nothing,
      endDate = Nothing,
      deadline = Nothing,
      fileName = "(no file)",
      lineNr = 0,
      itemNumber = 0}

groupByStatus' :: [Todo] -> [Todo]
groupByStatus' todos =
  map (\s -> statusTodo s todos) (allStatuses todos) ‚ß∫ todos

dirname :: FilePath -> FilePath
dirname path =
  case dropFileName path of
    [] -> []
    dir -> takeFileName (init dir)

fileTodo :: FilePath -> TodoItem
fileTodo path = Item {
  itemLevel = 0,
  itemPrefix = "",
  itemName = takeFileName path,
  itemTags = [dirname path],
  depends = [],
  itemStatus = ":",
  itemDescr = path,
  startDate = Nothing,
  endDate = Nothing,
  deadline = Nothing,
  fileName = path,
  lineNr = 0,
  itemNumber = 0}

todosGroup :: FilePath -> [TodoItem] -> [TodoItem]
todosGroup path items =
  if null items
    then []
    else fileTodo path: map (~+ 1) items

changeTopStatus :: Maybe String -> [Todo] -> [Todo]
changeTopStatus Nothing   todos = todos
changeTopStatus (Just st) todos = map setStatus todos
  where
    setStatus (Node item children) = Node (item {itemStatus = st}) children

-- | Load list of TODO trees from files
loadTodo :: BaseConfig
         -> DateTime      -- ^ Current date/time
         -> [FilePath]    -- ^ List of files
         -> IO [Todo]
loadTodo conf date paths = do
    let grp = if groupByFile conf
                then todosGroup
                else const id
    tss <- forM paths $ \path -> grp path `fmap` loadFile conf date path
    let todos = stitchTodos (concat tss)
        byTag = if groupByTag conf
                  then groupByTag' todos
                  else todos
        byStatus = if groupByStatus conf
                     then groupByStatus' byTag
                     else byTag
    return $ changeTopStatus (topStatus conf) byStatus


</pre>