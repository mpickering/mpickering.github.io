<a href="MapReduce.hs2035308228158374933.out.html">prev</a></br><a href="failures.html">home</a></br><a href="Markups.hs340756291478446501.out.html">next</a></br></br><pre>30c30
< antecedent âˆ· Rule c â†’ [c]
---
> antecedent :: Rule c -> [c]
35c35
< consequent âˆ· Rule c â†’ [c]
---
> consequent :: Rule c -> [c]
40c40
< constructor âˆ· Rule c â†’ ([d] â†’ [d] â†’ Rule d)
---
> constructor :: Rule c -> ([d] -> [d] -> Rule d)
52c52
< isChar âˆ· Var Î± â†’ Bool
---
> isChar :: Var Î± -> Bool
56c56
< isVar âˆ· Var Î± â†’ Bool
---
> isVar :: Var Î± -> Bool
60d59
< expand âˆ· Eq Î±
61d59
<        â‡’ [Î±]               -- ^ Alphabet
62d59
<        â†’ Algo (Var Î±)      -- ^ Algorithm with variables
63c60
<        â†’ Algo Î±
---
> expand :: Eq Î±
63a61
>        => [Î±]               -- ^ Alphabet
63a62
>        -> Algo (Var Î±)      -- ^ Algorithm with variables
63a63
>        -> Algo Î±
66c66
< expandRule âˆ· Eq Î± â‡’ [Î±] â†’ Rule (Var Î±) â†’ [Rule Î±]
---
> expandRule :: Eq Î± => [Î±] -> Rule (Var Î±) -> [Rule Î±]
69c69
< toChar âˆ· Rule (Var Î±) â†’ Rule Î±
---
> toChar :: Rule (Var Î±) -> Rule Î±
72c72
<     toChar' âˆ· [Var Î±] â†’ [Î±]
---
>     toChar' :: [Var Î±] -> [Î±]
78d77
< expandRule' âˆ· [Î±] â†’ Rule (Var Î±) â†’ [Rule (Var Î±)]
79c78
< expandRule' ğ” rule = [(constructor rule) a c | (a,c) â† expandString ğ” (antecedent rule) (consequent rule)]
---
> expandRule' :: [Î±] -> Rule (Var Î±) -> [Rule (Var Î±)]
79a79
> expandRule' ğ” rule = [(constructor rule) a c | (a,c) <- expandString ğ” (antecedent rule) (consequent rule)]
81c81
< expandString âˆ· [Î±] â†’ [Var Î±] â†’ [Var Î±] â†’ [([Var Î±], [Var Î±])]
---
> expandString :: [Î±] -> [Var Î±] -> [Var Î±] -> [([Var Î±], [Var Î±])]
87c87
< subst âˆ· [Var Î±] â†’ [Var Î±] â†’ [Î±] â†’ ([Var Î±], [Var Î±])
---
> subst :: [Var Î±] -> [Var Î±] -> [Î±] -> ([Var Î±], [Var Î±])
95c95
< parseString âˆ· Eq Î± â‡’ [Î±] â†’ [Î±] â†’ [Var Î±]
---
> parseString :: Eq Î± => [Î±] -> [Î±] -> [Var Î±]
99d98
<                 Nothing â†’ L c
100c99
<                 Just n  â†’ V n
---
>                 Nothing -> L c
100a100
>                 Just n  -> V n
103d102
< parseRule âˆ· Eq Î±
104d102
<           â‡’ [Î±]    -- ^ Names of variables
105d102
<           â†’ Rule Î± -- ^ Concrete rule
106c103
<           â†’ Rule (Var Î±)
---
> parseRule :: Eq Î±
106a104
>           => [Î±]    -- ^ Names of variables
106a105
>           -> Rule Î± -- ^ Concrete rule
106a106
>           -> Rule (Var Î±)
109c109
< replace âˆ· Eq Î± â‡’ [Î±] â†’ [Î±] â†’ [Î±] â†’ [Î±]
---
> replace :: Eq Î± => [Î±] -> [Î±] -> [Î±] -> [Î±]
115c115
< applyRule âˆ· Eq Î± â‡’ Rule Î± â†’ [Î±] â†’ (Maybe [Î±], Bool)
---
> applyRule :: Eq Î± => Rule Î± -> [Î±] -> (Maybe [Î±], Bool)
122c122
< shouldStop âˆ· Rule c â†’ Bool
---
> shouldStop :: Rule c -> Bool
127d126
< runMarkov âˆ· Eq Î±
128d126
<           â‡’ Algo Î±       -- ^ Algorithm itself
129d126
<           â†’ [Î±]          -- ^ Start string
130c127
<           â†’ [Î±]
---
> runMarkov :: Eq Î±
130a128
>           => Algo Î±       -- ^ Algorithm itself
130a129
>           -> [Î±]          -- ^ Start string
130a130
>           -> [Î±]
133c133
<     runMarkov' :: Eq Î± â‡’ Algo Î± â†’ Algo Î± â†’ [Î±] â†’ [Î±]
---
>     runMarkov' :: Eq Î± => Algo Î± -> Algo Î± -> [Î±] -> [Î±]
137d136
<         (Just res, False) â†’ runMarkov' algo algo res
138d136
<         (Just res, True)  â†’ res
139c137
<         (Nothing,  _)     â†’ runMarkov' algo rs s
---
>         (Just res, False) -> runMarkov' algo algo res
139a138
>         (Just res, True)  -> res
139a139
>         (Nothing,  _)     -> runMarkov' algo rs s
142d141
< buildAlgo âˆ· Eq Î±
143d141
<           â‡’ [Î±]     -- ^ Alphabet
144d141
<           â†’ [Î±]     -- ^ Names of variables
145d141
<           â†’ Algo Î±  -- ^ Description of algorithm
146c142
<           â†’ Algo Î±
---
> buildAlgo :: Eq Î±
146a143
>           => [Î±]     -- ^ Alphabet
146a144
>           -> [Î±]     -- ^ Names of variables
146a145
>           -> Algo Î±  -- ^ Description of algorithm
146a146
>           -> Algo Î±
148a149
> 
</pre></br><h2>original</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances #-}
module Data.MarkovAlgo
  (Algo, Rule (..), Var (..),
   antecedent, consequent, constructor,
   expand,
   parseRule,
   buildAlgo,
   runMarkov)
  where

import Data.List

-- | Markov's algorithm itself
type Algo c = [Rule c]

-- | One rule in algorithm
data Rule c = [c] :-> [c]   -- ^ Non-terminating rule
            | [c] :->. [c]  -- ^ Terminating rule
  deriving (Eq)

instance Show (Rule Char) where
  show (a :-> s) = a ++ " â†’ " ++ s
  show (a :->. s) = a ++ " â†’. " ++ s

instance Show (Rule (Var Char)) where
  show (a :-> s) = show a ++ " â†’ " ++ show s
  show (a :->. s) = show a ++ " â†’. " ++ show s

-- | Get antecedent of rule
antecedent âˆ· Rule c â†’ [c]
antecedent (xs :-> _) = xs
antecedent (xs :->. _) = xs

-- | Get consequent of rule
consequent âˆ· Rule c â†’ [c]
consequent (_ :-> ys) = ys
consequent (_ :->. ys) = ys

-- | Get data constructor of Rule
constructor âˆ· Rule c â†’ ([d] â†’ [d] â†’ Rule d)
constructor (_ :-> _) = (:->)
constructor (_ :->. _) = (:->.)

-- | Variable for rules
data Var Î± = L Î±    -- ^ Literal char
           | V Int  -- ^ Variable with given number

instance Show (Var Char) where
  show (L c) = [c]
  show (V c) = show c

isChar âˆ· Var Î± â†’ Bool
isChar (L _) = True
isChar _     = False

isVar âˆ· Var Î± â†’ Bool
isVar = not . isChar

-- | Expand algorithm with variables into algorithm without variables
expand âˆ· Eq Î±
       â‡’ [Î±]               -- ^ Alphabet
       â†’ Algo (Var Î±)      -- ^ Algorithm with variables
       â†’ Algo Î±
expand ğ” = concatMap (expandRule ğ”)

expandRule âˆ· Eq Î± â‡’ [Î±] â†’ Rule (Var Î±) â†’ [Rule Î±]
expandRule ğ” rule = nub $ map toChar (expandRule' ğ” rule)

toChar âˆ· Rule (Var Î±) â†’ Rule Î±
toChar rule = (constructor rule) (toChar' $ antecedent rule) (toChar' $ consequent rule)
  where
    toChar' âˆ· [Var Î±] â†’ [Î±]
    toChar' = map toChar''

    toChar'' (L c) = c
    toChar'' (V _) = error "Internal error"

expandRule' âˆ· [Î±] â†’ Rule (Var Î±) â†’ [Rule (Var Î±)]
expandRule' ğ” rule = [(constructor rule) a c | (a,c) â† expandString ğ” (antecedent rule) (consequent rule)]

expandString âˆ· [Î±] â†’ [Var Î±] â†’ [Var Î±] â†’ [([Var Î±], [Var Î±])]
expandString ğ” as cs
  = map (subst as cs) $ mapM (const ğ”) [1..n]
      where
        n = length (filter isVar (as ++ cs))

subst âˆ· [Var Î±] â†’ [Var Î±] â†’ [Î±] â†’ ([Var Î±], [Var Î±])
subst as cs xs = (subst' as xs, subst' cs xs)
  where
    subst' []        _      = []
    subst' (L c: vs) cs = L c: subst' vs cs
    subst' (V n: vs) cs = L (cs !! n): subst' vs cs
    subst' (V _: _)  [] = error "Internal error: too few arguments in `subst'!"

parseString âˆ· Eq Î± â‡’ [Î±] â†’ [Î±] â†’ [Var Î±]
parseString xs s = map toVar s
  where
    toVar c = case elemIndex c xs of
                Nothing â†’ L c
                Just n  â†’ V n

-- | Create generic Rule from concrete Rule
parseRule âˆ· Eq Î±
          â‡’ [Î±]    -- ^ Names of variables
          â†’ Rule Î± -- ^ Concrete rule
          â†’ Rule (Var Î±)
parseRule xs rule = (constructor rule) (parseString xs $ antecedent rule) (parseString xs $ consequent rule)

replace âˆ· Eq Î± â‡’ [Î±] â†’ [Î±] â†’ [Î±] â†’ [Î±]
replace _ _ [] = []
replace old new s@(c:cs)
  | old `isPrefixOf` s = new ++ (drop (length old) s)
  | otherwise          = c: replace old new cs

applyRule âˆ· Eq Î± â‡’ Rule Î± â†’ [Î±] â†’ (Maybe [Î±], Bool)
applyRule rule s | a `isInfixOf` s = (Just $ replace a c s, shouldStop rule)
                 | otherwise       = (Nothing, shouldStop rule)
                     where
                      a = antecedent rule
                      c = consequent rule

shouldStop âˆ· Rule c â†’ Bool
shouldStop (_ :-> _) = False
shouldStop (_ :->. _) = True

-- | Run concrete (without variables) Markov's algorithm
runMarkov âˆ· Eq Î±
          â‡’ Algo Î±       -- ^ Algorithm itself
          â†’ [Î±]          -- ^ Start string
          â†’ [Î±]
runMarkov algo s = runMarkov' algo algo s
  where
    runMarkov' :: Eq Î± â‡’ Algo Î± â†’ Algo Î± â†’ [Î±] â†’ [Î±]
    runMarkov' _ [] s = s
    runMarkov' algo (r:rs) s =
      case applyRule r s of
        (Just res, False) â†’ runMarkov' algo algo res
        (Just res, True)  â†’ res
        (Nothing,  _)     â†’ runMarkov' algo rs s

-- | Build concrete algo from simple text description with variables
buildAlgo âˆ· Eq Î±
          â‡’ [Î±]     -- ^ Alphabet
          â†’ [Î±]     -- ^ Names of variables
          â†’ Algo Î±  -- ^ Description of algorithm
          â†’ Algo Î±
buildAlgo ğ” vs algo = expand ğ” $ map (parseRule vs) algo

</pre></br><h2>printed</h2></br><pre>{-# LANGUAGE UnicodeSyntax, FlexibleInstances #-}
module Data.MarkovAlgo
  (Algo, Rule (..), Var (..),
   antecedent, consequent, constructor,
   expand,
   parseRule,
   buildAlgo,
   runMarkov)
  where

import Data.List

-- | Markov's algorithm itself
type Algo c = [Rule c]

-- | One rule in algorithm
data Rule c = [c] :-> [c]   -- ^ Non-terminating rule
            | [c] :->. [c]  -- ^ Terminating rule
  deriving (Eq)

instance Show (Rule Char) where
  show (a :-> s) = a ++ " â†’ " ++ s
  show (a :->. s) = a ++ " â†’. " ++ s

instance Show (Rule (Var Char)) where
  show (a :-> s) = show a ++ " â†’ " ++ show s
  show (a :->. s) = show a ++ " â†’. " ++ show s

-- | Get antecedent of rule
antecedent :: Rule c -> [c]
antecedent (xs :-> _) = xs
antecedent (xs :->. _) = xs

-- | Get consequent of rule
consequent :: Rule c -> [c]
consequent (_ :-> ys) = ys
consequent (_ :->. ys) = ys

-- | Get data constructor of Rule
constructor :: Rule c -> ([d] -> [d] -> Rule d)
constructor (_ :-> _) = (:->)
constructor (_ :->. _) = (:->.)

-- | Variable for rules
data Var Î± = L Î±    -- ^ Literal char
           | V Int  -- ^ Variable with given number

instance Show (Var Char) where
  show (L c) = [c]
  show (V c) = show c

isChar :: Var Î± -> Bool
isChar (L _) = True
isChar _     = False

isVar :: Var Î± -> Bool
isVar = not . isChar

-- | Expand algorithm with variables into algorithm without variables
expand :: Eq Î±
       => [Î±]               -- ^ Alphabet
       -> Algo (Var Î±)      -- ^ Algorithm with variables
       -> Algo Î±
expand ğ” = concatMap (expandRule ğ”)

expandRule :: Eq Î± => [Î±] -> Rule (Var Î±) -> [Rule Î±]
expandRule ğ” rule = nub $ map toChar (expandRule' ğ” rule)

toChar :: Rule (Var Î±) -> Rule Î±
toChar rule = (constructor rule) (toChar' $ antecedent rule) (toChar' $ consequent rule)
  where
    toChar' :: [Var Î±] -> [Î±]
    toChar' = map toChar''

    toChar'' (L c) = c
    toChar'' (V _) = error "Internal error"

expandRule' :: [Î±] -> Rule (Var Î±) -> [Rule (Var Î±)]
expandRule' ğ” rule = [(constructor rule) a c | (a,c) <- expandString ğ” (antecedent rule) (consequent rule)]

expandString :: [Î±] -> [Var Î±] -> [Var Î±] -> [([Var Î±], [Var Î±])]
expandString ğ” as cs
  = map (subst as cs) $ mapM (const ğ”) [1..n]
      where
        n = length (filter isVar (as ++ cs))

subst :: [Var Î±] -> [Var Î±] -> [Î±] -> ([Var Î±], [Var Î±])
subst as cs xs = (subst' as xs, subst' cs xs)
  where
    subst' []        _      = []
    subst' (L c: vs) cs = L c: subst' vs cs
    subst' (V n: vs) cs = L (cs !! n): subst' vs cs
    subst' (V _: _)  [] = error "Internal error: too few arguments in `subst'!"

parseString :: Eq Î± => [Î±] -> [Î±] -> [Var Î±]
parseString xs s = map toVar s
  where
    toVar c = case elemIndex c xs of
                Nothing -> L c
                Just n  -> V n

-- | Create generic Rule from concrete Rule
parseRule :: Eq Î±
          => [Î±]    -- ^ Names of variables
          -> Rule Î± -- ^ Concrete rule
          -> Rule (Var Î±)
parseRule xs rule = (constructor rule) (parseString xs $ antecedent rule) (parseString xs $ consequent rule)

replace :: Eq Î± => [Î±] -> [Î±] -> [Î±] -> [Î±]
replace _ _ [] = []
replace old new s@(c:cs)
  | old `isPrefixOf` s = new ++ (drop (length old) s)
  | otherwise          = c: replace old new cs

applyRule :: Eq Î± => Rule Î± -> [Î±] -> (Maybe [Î±], Bool)
applyRule rule s | a `isInfixOf` s = (Just $ replace a c s, shouldStop rule)
                 | otherwise       = (Nothing, shouldStop rule)
                     where
                      a = antecedent rule
                      c = consequent rule

shouldStop :: Rule c -> Bool
shouldStop (_ :-> _) = False
shouldStop (_ :->. _) = True

-- | Run concrete (without variables) Markov's algorithm
runMarkov :: Eq Î±
          => Algo Î±       -- ^ Algorithm itself
          -> [Î±]          -- ^ Start string
          -> [Î±]
runMarkov algo s = runMarkov' algo algo s
  where
    runMarkov' :: Eq Î± => Algo Î± -> Algo Î± -> [Î±] -> [Î±]
    runMarkov' _ [] s = s
    runMarkov' algo (r:rs) s =
      case applyRule r s of
        (Just res, False) -> runMarkov' algo algo res
        (Just res, True)  -> res
        (Nothing,  _)     -> runMarkov' algo rs s

-- | Build concrete algo from simple text description with variables
buildAlgo :: Eq Î±
          => [Î±]     -- ^ Alphabet
          -> [Î±]     -- ^ Names of variables
          -> Algo Î±  -- ^ Description of algorithm
          -> Algo Î±
buildAlgo ğ” vs algo = expand ğ” $ map (parseRule vs) algo


</pre>