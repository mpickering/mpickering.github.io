<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>An IDE implemented using reflex</title>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
        <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link href="https://fonts.googleapis.com/css?family=Vollkorn" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div class="container">
          <div class="row">
            <div class="col-sm-auto">
              <ul class="nav flex-column">
              <li class="nav-item">
                <a href="../">Home</a>
              </li>
              <li class="nav-item">
                <a href="../about.html">About</a> <br>
              </li>
              <li>
                <a href="../publications.html">Publications</a>
              </li>
              <li>
                <a href="../plugins.html">Plugins</a>
              </li>
              <li>
                <a href="../eventlog2html">eventlog2html</a>
              </li>
              <li>
                <a href="../ide/index.html">
                <img style="height: 0.9em; margin-right: 2px;" src="../ide/images/haskell-logo.svg" /></span>
                IDE 2020</a>
              </li>
          <!---
              <li>
                <a href="/bristol2020.html">Bristol 2020</a>
              </li>
              <li>
                <a href="https://andreaspk.github.io/ghc-week">GHC Week</a>
              </li>
          --->
              <li>
                <a href="../maps.html">Maps</a>
              </li>
              <li>
                <a href="../hurstwood.html">Hurstwood TrailO</a>
              </li>
              <li class="nav-item">
                <a href="../archive.html">Archive</a> <br>
              </li>
              <li>
                <a href="../atom.xml">Feed</a>
              </li>
              </ul>
            </div>
          <div class="col-md">

            <div id="content">
              <h2> An IDE implemented using reflex </h2>
<p class="text-muted">
    Posted on March 16, 2020
    
</p>

<p>Around this point last year I set out to reimplement a lot of the backend of <code>haskell-ide-engine</code> in order to make it more easily usable with a wide variety of build tools. This effort was largely a success and my branch was merged just before Christmas thanks to the extensive help of Zubin Duggal, Fendor, Alan Zimmerman, Luke Lau and Javier Neira. The main result was an IDE based on the <code>hie-bios</code> library which abstracts the interface to the different build tools so the IDE itself doesnâ€™t have to worry about how to set up the GHC session.</p>
<p>Since then, the situation is vastly different with the focus now turning to <code>ghcide</code> and <code>hls</code>. <code>ghcide</code> is generally faster and more robust than <code>haskell-ide-engine</code> because it reimplements certain parts of the GHC API which allow for finer grain recompilation checking. The future extension, <code>hls</code>, will extend <code>ghcide</code> with support for code formatters and other diagnostics. I have found implementing extensions to <code>ghcide</code> much easier and more robust. Both <code>ghcide</code> and <code>hls</code> are built on top of <code>hie-bios</code>.</p>
<p>At Munihac 2019, Neil Mitchell gave a <a href="https://www.youtube.com/watch?v=cijsaeWNf2E">presentation</a> where he described the motivation for <code>ghcide</code> and a general description of the architecture. In his talk, he describes how you can think of an IDE as a dependency graph, which was greeted by an audience heckle suggesting an FRP library could be used to implement the IDE. The current implementation is based on shake, which has similar properties to an FRP library but with some crucial differences.</p>
<p>The pull-based model of shake does not scale well to large code bases. All requests scale linearly with the number of dependencies which means that even requests such as hovering can take upwards of 1s on a module with a large number of transitive dependencies. A 1s hover response time was enough to get me interested and after attempting to <a href="https://github.com/digital-asset/ghcide/pull/384">improve the performance</a> I decided that without a fundamental rewrite, the situation could not be improved.</p>
<p>So spurred on by the heckle and the desire for subsecond reponse times it was time to put the money where my mouth was and attempt to reimplement the backend using <code>reflex</code> instead of <code>shake</code>. Reflex is push-based which means once the network is constructed changes propagate from input events rather than being pulled from samples. This seemed like a better model for an IDE.</p>
<p>What did I imagine the primary benefits to this project would be?</p>
<ul>
<li>I wanted to prove it was possible.</li>
<li>Using the push-based model means that requests such as hovering can return instantly rather than checking to see if any dependencies have updated.</li>
<li>Handlers for LSP requests can be written in the same language as the functions which computed the module graph.</li>
</ul>
<p>In short, I <a href="https://github.com/mpickering/ghcide-reflex/tree/reflex">now have an IDE</a> which works and is completely implemented using reflex which gives you a point to be able to evaluate the costs and benefits to both approaches.</p>
<p>In this post I will describe some of the basic abstractions which I implemented using <code>reflex</code> which gives writing the IDE a similar feel. The rest of this post is aimed at people who are already familiar with <code>reflex</code> and goes into a reasonable amount of detail about specific things to do with reflex and design decisions I had to make.</p>
<!--more-->
<h1 id="implementation">Implementation</h1>
<p>An early goal of the implementation was to try to reuse as much code as possible from <code>ghcide</code>. The end result was that I could reuse almost all the code for the rule definitions but had to rewrite a lot of the code which dealt with input events. Therefore there are two main parts to the implementation: the specification of rules and the interpretation of rules into a reflex network.</p>
<h2 id="step-1-what-is-a-rule">Step 1: What is a rule?</h2>
<p>The program is structured by rules, there is one rule type for each of the different stages of the compilation pipeline. The user provides definitions for these rules and then the rules are combined to form the reflex network.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RuleType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">GetFileContents</span><span class="ot"> ::</span> <span class="dt">RuleType</span> (<span class="dt">FileVersion</span>, <span class="dt">Maybe</span> <span class="dt">T.Text</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="dt">GetParsedModule</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">ParsedModule</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="dt">GetLocatedImports</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">LocatedImports</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="dt">GetSpanInfo</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">SpansInfo</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  <span class="dt">GetDependencyInformation</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">DependencyInformation</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="dt">GetDependencies</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">TransitiveDependencies</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="dt">GetTypecheckedModule</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">TcModuleResult</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="dt">ReportImportCycles</span><span class="ot"> ::</span> <span class="dt">RuleType</span> ()</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="dt">GenerateCore</span><span class="ot"> ::</span> <span class="dt">RuleType</span> (<span class="dt">SafeHaskellMode</span>, <span class="dt">CgGuts</span>, <span class="dt">ModDetails</span>)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  <span class="dt">GenerateByteCode</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">Linkable</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="dt">GhcSession</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">HscEnvEq</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="dt">GetHiFile</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">HiFileResult</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  <span class="dt">GetModIface</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">HiFileResult</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  <span class="dt">IsFileOfInterest</span><span class="ot"> ::</span> <span class="dt">RuleType</span> <span class="dt">Bool</span></a></code></pre></div>
<p>A <code>RuleType</code> is a per-module rule, therefore for each module we can ask to get the parsed module for that module and a bunch of other information. As a first approximation, the result of each rule will be stored in a <code>Dynamic</code>.</p>
<p>The monad which is used for defining rules is called <code>ActionM</code>, inside the <code>ActionM</code> monad you can do two things.</p>
<ol type="1">
<li>Run IO actions using <code>liftIO</code>.</li>
<li>Request the value of existing rules, using <code>use</code> or <code>use_</code>.</li>
</ol>
<p><code>use</code> is a function which allows you to ask what the current value of a specific rule is.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">use ::</span> _ <span class="ot">=&gt;</span> <span class="dt">RuleType</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">         <span class="ot">-&gt;</span> <span class="dt">NormalizedFilePath</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">         <span class="ot">-&gt;</span> <span class="dt">ActionM</span> t m (<span class="dt">Maybe</span> a)</a></code></pre></div>
<p>Whenever <code>use</code> is invoked in a rule definition, a dependency is added on the value was was sampled. If the value changes in future, the rule will run again and the result recomputed.</p>
<p>Rule definition therefore end up looking a lot like the original shake rule definitions.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">generateByteCodeRule ::</span> <span class="dt">WRule</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">generateByteCodeRule <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    define <span class="dt">GenerateByteCode</span> <span class="fu">$</span> \file <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      deps <span class="ot">&lt;-</span> use_ <span class="dt">GetDependencies</span> file</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      (tm <span class="fu">:</span> tms) <span class="ot">&lt;-</span> uses_ <span class="dt">GetTypecheckedModule</span> (file<span class="fu">:</span> transitiveModuleDeps deps)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">      session <span class="ot">&lt;-</span> hscEnv <span class="fu">&lt;$&gt;</span> use_ <span class="dt">GhcSession</span> file</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">      (_, guts, _) <span class="ot">&lt;-</span> use_ <span class="dt">GenerateCore</span> file</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      liftIO <span class="fu">$</span> generateByteCode session [(tmrModSummary x, tmrModInfo x) <span class="fu">|</span> x <span class="ot">&lt;-</span> tms] tm guts</a></code></pre></div>
<p>The bytecode rule will rerun if the dependencies of the file change, the result of typechecking changes, the current session changes or the generated core changes.</p>
<h3 id="defining-rules">Defining rules</h3>
<p>Once the body of a rule definition is defined, there are several ways to specify the definition. The simplest is <code>define</code>, which does not implement early cut-off or external triggering. There are other variants which enable both of these features.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">define ::</span> <span class="dt">RuleType</span> a <span class="ot">-&gt;</span> (forall t <span class="fu">.</span> <span class="dt">C</span> t <span class="ot">=&gt;</span> <span class="dt">NormalizedFilePath</span> <span class="ot">-&gt;</span> <span class="dt">ActionM</span> t (<span class="dt">HostFrame</span> t) a) <span class="ot">-&gt;</span> <span class="dt">WRule</span></a></code></pre></div>
<p>Once a rule is defined, like in shake, you put them all in a list and pass them into the function which creates the reflex network.</p>
<h2 id="representing-a-node-in-the-network">Representing a node in the network</h2>
<p>Each rule is implemented by an <code>MDynamic</code>, which is a refined <code>Dynamic</code> which implements early cut-off and lazy initialisation. Early cut-off means that the dynamic will only fire if the value is updated to a new value. Lazy initialisation means that the dynamic will only be populated after it has been demanded once.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">MDynamic</span> t a <span class="fu">=</span> <span class="dt">MDynamic</span> {<span class="ot"> getMD ::</span> <span class="dt">Dynamic</span> t (<span class="dt">Early</span> (<span class="dt">Thunk</span> a)) }</a></code></pre></div>
<p>The combination of both of these features means that less events are propagated in the network, something we really want to avoid in order to avoid running expensive IO computations.</p>
<h3 id="early-cut-off">Early Cut-off</h3>
<p>Early cut-off is implemented by using the <code>Early</code> wrapper.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Early</span> a <span class="fu">=</span> <span class="dt">Early</span> (<span class="dt">Maybe</span> <span class="dt">BS.ByteString</span>) <span class="dt">Int</span> a</a></code></pre></div>
<p>The data type stores a hash of the current value and an integer which indicates the number of times the value has been updated (this is used for debugging).</p>
<p>The value in the <code>Early</code> is only updated if either there is no hash or the hash of the new value is different to the hash of the old value.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">early ::</span> (<span class="dt">Reflex</span> t, <span class="dt">MonadHold</span> t m, <span class="dt">MonadFix</span> m) <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> t (<span class="dt">Maybe</span> <span class="dt">BS.ByteString</span>, a) <span class="ot">-&gt;</span> m (<span class="dt">Dynamic</span> t (<span class="dt">Early</span> a))</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">early d <span class="fu">=</span> scanDynMaybe (\(h, v) <span class="ot">-&gt;</span> <span class="dt">Early</span> h <span class="dv">0</span> v) upd d</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="co">-- Nothing means there's no hash, so always update</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    upd (<span class="dt">Nothing</span>, a) (<span class="dt">Early</span> _ n _) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Early</span> <span class="dt">Nothing</span> (n <span class="fu">+</span> <span class="dv">1</span>) a)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    <span class="co">-- If there's already a hash, and we get a new hash then update</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    upd (<span class="dt">Just</span> h, new_a) (<span class="dt">Early</span> (<span class="dt">Just</span> h') n _) <span class="fu">=</span> <span class="kw">if</span> h <span class="fu">==</span> h'</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">                                                  <span class="kw">then</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">                                                  <span class="kw">else</span> (<span class="dt">Just</span> (<span class="dt">Early</span> (<span class="dt">Just</span> h') (n <span class="fu">+</span> <span class="dv">1</span>) new_a))</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    <span class="co">-- No stored, hash, just update</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    upd (h, new_a) (<span class="dt">Early</span> <span class="dt">Nothing</span> n _)   <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Early</span> h (n <span class="fu">+</span> <span class="dv">1</span>) new_a)</a></code></pre></div>
<p>Most rules do not use the early cut-off functionality and hence the hash is always <code>Nothing</code>.</p>
<h3 id="lazy-initialisation">Lazy initialisation</h3>
<p>Without proper care, when the state for a module is initialised all the information about that module will be computed despite the fact most of it will never be used. For example, you will not need the core for most modules but in early versions of the project the core was always produced because on the first run of the rule, it was observed to depend on the typechecked module and hence was updated when the typechecked module was updated.</p>
<p>In order to solve this we implement the <code>Thunk</code> data type which has three distinct states:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Thunk</span> a <span class="fu">=</span> <span class="dt">Value</span> a <span class="fu">|</span> <span class="dt">Awaiting</span> <span class="fu">|</span> <span class="dt">Seed</span> (<span class="dt">IO</span> ()) <span class="kw">deriving</span> <span class="dt">Functor</span></a></code></pre></div>
<p>A thunk either contains a value, is awaiting a value to be provided to it or is inactive. All thunks start out as inactive and are activated by calling the <code>IO</code> action contained within the <code>Seed</code> constructor.</p>
<p>When a thunk is sampled, it is activated if it has never been activated before.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">sampleThunk ::</span> (<span class="dt">Reflex</span> t, <span class="dt">MonadIO</span> m, <span class="dt">MonadSample</span> t m) <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> t (<span class="dt">Thunk</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">sampleThunk d <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  t <span class="ot">&lt;-</span> sample (current d)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="kw">case</span> t <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="dt">Seed</span> start <span class="ot">-&gt;</span> liftIO start <span class="fu">&gt;&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="dt">Awaiting</span>   <span class="ot">-&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="dt">Value</span> a    <span class="ot">-&gt;</span> return (<span class="dt">Just</span> a)</a></code></pre></div>
<p>It is also important to implement a version of the <code>improvingMaybe</code> combinator to avoid propagating a lot of updates in the case when the dynamic is repeatedly updated to an <code>Awaiting</code> value. So a thunk can step from a <code>Seed</code> to an <code>Awaiting</code> and from an <code>Awaiting</code> to a <code>Value</code> but never back again.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- Like improvingMaybe, but for the Thunk type</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">improvingResetableThunk  ::</span>  (<span class="dt">MonadFix</span> m, <span class="dt">MonadHold</span> t m, <span class="dt">Reflex</span> t, <span class="dt">MonadIO</span> m, <span class="dt">MonadSample</span> t m) <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> t (<span class="dt">Thunk</span> a) <span class="ot">-&gt;</span> m (<span class="dt">Dynamic</span> t (<span class="dt">Thunk</span> a))</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">improvingResetableThunk <span class="fu">=</span> scanDynMaybe id upd</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="co">-- ok, if you insist, write the new value</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    upd (<span class="dt">Value</span> a) _ <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Value</span> a)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    <span class="co">-- Wait, once the trigger is pressed</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    upd <span class="dt">Awaiting</span>  (<span class="dt">Seed</span> {}) <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Awaiting</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    upd _ _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>It will be good in future to allow resetting thunks in order to implement garbage collection. It is probably that we want to allow reseting from a <code>Just</code> back to a <code>Nothing</code> in order to avoid stale information in the network.</p>
<h2 id="step-2-what-is-a-global-variable">Step 2: What is a global variable?</h2>
<p>There is also a global rule type for parts of the IDE state which are not dependent on a specific module.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">GlobalType</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="dt">GetHscEnv</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">SessionMap</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="dt">GhcSessionIO</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">GhcSessionFun</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="dt">GetEnv</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">HscEnv</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  <span class="dt">GetIdeOptions</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">IdeOptions</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="dt">OfInterestVar</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> (<span class="dt">HashSet</span> <span class="dt">NormalizedFilePath</span>)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  <span class="dt">FileExistsMapVar</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">FileExistsMap</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="dt">GetVFSHandle</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">VFSHandle</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="dt">GetInitFuncs</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">InitParams</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  <span class="dt">IdeConfigurationVar</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">IdeConfiguration</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  <span class="dt">GetPositionMap</span><span class="ot"> ::</span> <span class="dt">GlobalType</span> <span class="dt">PositionMap</span></a></code></pre></div>
<p>Module rules can depend on global rules in the same manner as per-module rules. The interface for defining a global rule is slightly different to a local rule because the global variables are usually directly populated from events. For example, the <code>OfInterestVar</code> is modified by the user opening and closing files in their editer and hence it is defined as the combination of these two events.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">addIdeGlobal ::</span> <span class="dt">GlobalType</span> a <span class="ot">-&gt;</span> (forall t <span class="fu">.</span> <span class="dt">C</span> t <span class="ot">=&gt;</span> (<span class="dt">ReaderT</span> (<span class="dt">REnv</span> t) m (<span class="dt">Dynamic</span> t a))) <span class="ot">-&gt;</span> <span class="dt">WRule</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">ofInterestVar ::</span> <span class="dt">WRule</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">ofInterestVar <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  addIdeGlobal <span class="dt">OfInterestVar</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    e1 <span class="ot">&lt;-</span> withNotification <span class="fu">&lt;$&gt;</span> getHandlerEvent didOpenTextDocumentNotificationHandler</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    e2 <span class="ot">&lt;-</span> withNotification <span class="fu">&lt;$&gt;</span> getHandlerEvent didCloseTextDocumentNotificationHandler</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">    upd <span class="ot">&lt;-</span> logAction <span class="dt">Info</span> (fmapMaybe check e1)</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    upd2 <span class="ot">&lt;-</span> logAction <span class="dt">Info</span> (fmapMaybe check2 e2)</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    foldDyn (<span class="fu">$</span>) S.empty (mergeWith (<span class="fu">.</span>) [upd, upd2])</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">      check (<span class="dt">DidOpenTextDocumentParams</span> <span class="dt">TextDocumentItem</span>{_uri, _version}) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">        whenUriFile _uri <span class="dt">Nothing</span> <span class="fu">$</span> \file <span class="ot">-&gt;</span> <span class="dt">Just</span> (add file, <span class="st">&quot;Opened text document: &quot;</span> <span class="fu">&lt;&gt;</span> getUri _uri)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"></a>
<a class="sourceLine" id="cb12-16" data-line-number="16">      check2 (<span class="dt">DidCloseTextDocumentParams</span> <span class="dt">TextDocumentIdentifier</span>{_uri}) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">        whenUriFile _uri <span class="dt">Nothing</span> <span class="fu">$</span> \file <span class="ot">-&gt;</span> <span class="dt">Just</span> (remove file, <span class="st">&quot;Closed text document:&quot;</span> <span class="fu">&lt;&gt;</span> getUri _uri)</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">      add file <span class="fu">=</span> S.insert file</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">      remove file <span class="fu">=</span> S.delete file</a></code></pre></div>
<p>A global is defined in an environment with the other global dynamics and must return a dynamic which is created by combining them together.</p>
<h2 id="definition-3-what-is-an-unit-action">Definition 3: What is an unit action?</h2>
<p>The third type of definition is the unit action. Unit actions are useful for parts of your program which donâ€™t contribute any state in the form of definitions. For example, hooking up diagnostics to the output, responding to hover requests, logging and progress notifications.</p>
<p>Unit actions are defined using the <code>unitAction</code> function.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">unitAction ::</span> (forall t <span class="fu">.</span> <span class="dt">C</span> t <span class="ot">=&gt;</span> <span class="dt">BasicM</span> t (<span class="dt">BasicGuestWrapper</span> t) ())</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">           <span class="ot">-&gt;</span> <span class="dt">WRule</span></a></code></pre></div>
<p>A unit action is an action which only operates in a reader environment where it can depend on the value of other dynamics but must eventually return unit. For example, in a unit action you can create a local dynamic which combines different dynamics from the global state together before outputting the result to the user. This is how diagnostics are implemented before being fed into the function which sends output back to the language client.</p>
<h1 id="evaluating-the-rule-specification">Evaluating the rule specification</h1>
<p>Once we have a list of module rules, global rules and actions, they are combined together in order to form the reflex network. Each global rule is evaluated and turned into a dynamic, module rules are used to define the per-module state when we discover a new file and finally actions are all evaluated to connect additional parts of the network together.</p>
<h2 id="evaluating-a-rule">Evaluating a rule</h2>
<p>The heart of the implementation is in how the rules report their dependencies in the form of an <code>Event</code>, which is then used in order to trigger the action in future. This is elegantly expressed recursively in five lines. The result of the call to performAction is <code>Event t (IdeResult a, [Event t EType])</code>, which is the separated using <code>splitE</code> before the dependency events are combined with <code>mkDepTrigger</code> and then used in order to define <code>rebuild_trigger</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">rule <span class="fu">=</span> mdo</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="co">-- The event which will trigger a rebuild</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="kw">let</span> rebuild_trigger <span class="fu">=</span> (fmap (\e <span class="ot">-&gt;</span> leftmost [user_trig', start_trigger, e]) deps')</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    act_trig <span class="ot">&lt;-</span> switchHoldPromptly start_trigger rebuild_trigger</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="co">-- When the trigger fires, run the rule</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    pm <span class="ot">&lt;-</span> performAction renv (act f) act_trig</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="co">-- Separate the dependencies from the actual result</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="kw">let</span> (act_res, deps) <span class="fu">=</span> splitE pm</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="kw">let</span> deps' <span class="fu">=</span> pushAlways mkDepTrigger deps</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">    <span class="fu">...</span></a></code></pre></div>
<p>The use of <code>switchHoldPromptly</code> is absolutely key to the implementation. It is imperative that if in the same frame a dependency fires then we need to immediately rerun the rule. The network is left in an inconsistent state is the simpler <code>switchHold</code> is used.</p>
<p>Further processing to the returned result is performed to convert it into an <code>MDynamic</code> which is then stored in the state.</p>
<h2 id="a-note-about-the-module-state">A note about the module state</h2>
<p>The per-module state is a pair of a map from the rule type to an <code>MDynamic</code> and an event which reports diagnostics for that module.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ModuleState</span> t <span class="fu">=</span> <span class="dt">ModuleState</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">      {<span class="ot"> rules ::</span> <span class="dt">DMap</span> <span class="dt">RuleType</span> (<span class="dt">MDynamic</span> t)</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">      ,<span class="ot"> diags ::</span> <span class="dt">Event</span> t (<span class="dt">NL.NonEmpty</span> <span class="dt">DiagsInfo</span>) }</a></code></pre></div>
<p>The state for all modules is stored in a map from the filepath to one of these module state records.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ModuleMap</span> t <span class="fu">=</span> <span class="dt">Incremental</span> t (<span class="dt">PatchMap</span> <span class="dt">NormalizedFilePath</span> (<span class="dt">ModuleState</span> t))</a></code></pre></div>
<p>Using a <code>Dynamic</code> or <code>Incremental</code> here is important because it means values of the map can be altered as the network is evaluated. For our use-case as we do not know the dependencies of a module until we have parsed the module header.</p>
<p>So when a module rule is attempted to be sampled, there are in fact two possible modes of failure which we can recover from.</p>
<ol type="1">
<li>Either the module has never been seen before, so we should initialise the module state for this module.</li>
<li>The value for the rule has not been computed yet, so we should recompute the rule when it is available.</li>
</ol>
<p>In order to report that a sample failed for the first reason, the module map is paired with an action which can be called to trigger the event which adds a new module to the map.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ModuleMapWithUpdater</span> t <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="dt">MMU</span> {</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">    getMap ::</span> <span class="dt">ModuleMap</span> t</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    ,<span class="ot"> updateMap ::</span> [(<span class="dt">D.Some</span> <span class="dt">RuleType</span>, <span class="dt">NormalizedFilePath</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    }</a></code></pre></div>
<p>The second situation is dealt with by the <code>Thunk</code> mechanism described in the previous situation.</p>
<p>Note: There is a place where using <code>batchOccurences</code> is very useful because during the initialisation of the network, this trigger can be called hundreds of times and it is much more efficient to collect together as many updates as possible.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">map_update' <span class="ot">&lt;-</span> fmap concat <span class="fu">&lt;$&gt;</span> batchOccurrences <span class="fl">0.1</span> map_update</a></code></pre></div>
<h1 id="interaction-with-the-language-client">Interaction with the language client</h1>
<p>In the global environment as well as the global variables as defined by rules, there is a collection of events which correspond to external events.</p>
<ul>
<li>One event which fires after the language server is initialised, this populates a few global dynamics.</li>
<li>A record of events which fire whenever the server recieves a notification of request from the client. For example, when the user opens or modifies a file, the event fires.</li>
</ul>
<p>As part of an action definition it is possible to also provide an additional event trigger, constructed from these events, which causes the rule to fire. For example, when a file is saved, the rule which parses a file fires again which causes the changes to propagate through the network.</p>
<p>Global variables are typically constructed by holding these notification events. It is a much nicer model in my opinion than the style previously found in <code>ghcide</code> where there where some variables were mutated in the handlers and the whole shake graph invalidated.</p>
<p>Note: The way this handler record is constructed by leveraging the <code>barbies</code> library is <a href="https://github.com/mpickering/ghcide-reflex/blob/reflex/src/Development/IDE/Core/Reflex/Service.hs#L257">interesting</a> in its own right.</p>
<h1 id="evaluation">Evaluation</h1>
<p>I found it important to be able to inspect certain properties of my network during the implementation process. In particular, there were situations where actions were running more than I expected so I wanted to analyse what was causing each rule to fire. There is unfortunately not an existing framework built into reflex for this but it was possible to instrument the application to get some good information.</p>
<p>I started by defining a data type which enumerates the different possible ways a rule can fire.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- EType is mainly used for debugging why an event is firing too often.</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="kw">data</span> <span class="dt">EType</span> <span class="fu">=</span> <span class="dt">DepTrigger</span> (<span class="dt">D.Some</span> <span class="dt">RuleType</span>, <span class="dt">NormalizedFilePath</span>)</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">              <span class="fu">|</span> <span class="dt">MissingTrigger</span> <span class="dt">NormalizedFilePath</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">              <span class="fu">|</span> <span class="dt">StartTrigger</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">              <span class="fu">|</span> <span class="dt">UserTrigger</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">      <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>Then each event which could contribute to an action firing is tagged with one of these constructors. When the event fires I used <code>traceEvent</code> in order to output both the action which was firing and the reason for it. Then by capturing this log and using standard unix commands it was possible to analyse situations where things were happening more often than not.</p>
<p>This was the method where I realised it was necessary to use <code>headE</code> in order to make sure the <code>StartTrigger</code> event would only fire one time.</p>
<h1 id="whats-next">Whatâ€™s next?</h1>
<p>So weâ€™ve achieved our goal of proving the implementation is possible but there are still a few places the implementation could be improved. I have also not extensively tested the branch, it is likely there are some bugs to do with stale information.</p>
<h3 id="progress-reporting">Progress Reporting</h3>
<p>It isnâ€™t clear to me how to implement progress reporting for the IDE at the moment. All changes to the system are driven by push events, which means that when an event fires the amount of work which will be done can not be determined. This is compounded by the fact reflex is a monadic FRP library so how much is left to do depends on the result of running the rules.</p>
<h3 id="better-profiling">Better Profiling</h3>
<p>It would be good to have a profiling mode like shakeâ€™s profiling mode so the effect of each input event could be analysed in detail. At the moment there is nothing in the reflex ecosystem which can help with this analysis.</p>
<h3 id="asynchronous-actions">Asynchronous Actions</h3>
<p>It would be very beneficial if the rules could run in separate threads because currently the whole application blocks whilst IO actions are being computed. The usage of <code>MonadSample</code> is not currently compatible with using <code>performEvent</code> asynchronously.</p>
<h3 id="dynamic-rule-registration">Dynamic Rule Registration</h3>
<p>For my own sanity, I decided to use a fixed set of rules, as defined by <code>RuleType</code> in my implementation rather than a dynamic map of rules, as implemented in shake. I have considered a few types going for the dynamic map approach, as it would also be useful for plugins but it has been a low priority for the proof of concept implementation.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I had a great time implementing this fork, my second extensive rewrite of a Haskell IDE. Iâ€™m looking forward to rewriting an IDE again next year.</p>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="https://github.com/mpickering/ghcide-reflex">Project Branch</a></li>
<li><a href="https://channel9.msdn.com/Blogs/Seth-Juarez/Anders-Hejlsberg-on-Modern-Compiler-Construction">Anders Hejlsberg on Modern Compiler Construction</a></li>
<li><a href="https://www.youtube.com/watch?v=N6b44kMS6OM">Responsive compilers - Nicholas Matsakis - PLISS 2019</a></li>
<li><a href="https://www.reddit.com/r/haskell/comments/fjq4c2/an_ide_implemented_using_reflex/">Reddit discussion</a></li>
</ul>

            </div>
          </div>
        </div>
      </div>
    </body>
</html>
