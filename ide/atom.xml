<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>IDE 2020 Updates</title>
    <link href="http://mpickering.github.io//ide/atom.xml" rel="self" />
    <link href="http://mpickering.github.io/" />
    <id>http://mpickering.github.io//ide/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2020-08-04T00:00:00Z</updated>
    <entry>
    <title>2020-08-04-measuring-memory-size</title>
    <link href="http://mpickering.github.io//ide/posts/2020-08-04-measuring-memory-size.html" />
    <id>http://mpickering.github.io//ide/posts/2020-08-04-measuring-memory-size.html</id>
    <published>2020-08-04T00:00:00Z</published>
    <updated>2020-08-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Measuring memory usage of Haskell values and patching GHC </h2>
<p class="text-muted">
    Posted on August  4, 2020 by <a href="https://github.com/mpardalos">Michail Pardalos</a>
    <span class="avatar"><img src="/ide/images/mpardalos.png"/></span>
</p>

<p>As part of my Google Summer of Code project to add instrumentation to ghcide, I needed to measure the size of Haskell values in memory. After getting blocked by a bug in a GHC primop I fell down a rabbit hole of learning about GHC’s memory layout, C– and making my first contribution to GHC.</p>
<!--more-->
<p>In this post I want to describe that journey and hopefully encourage some more people to consider contributing to GHC. I will be explaining the concepts that were new to me, however some will still be unfamiliar to some people. I encourage you to look for them in the excellent <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/home">GHC wiki</a>. Ctrl-f in the <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/index">table of contents</a> will most likely get you a good explanation.</p>
<h2 id="the-prompt">The prompt</h2>
<p>This all started when one of my GSoC mentors, Matthew Pickering, suggested that I use the <a href="https://github.com/def-/ghc-datasize">ghc-datasize</a> library to measure the in-memory size of a large hashmap at the core of ghcide. This would be useful as memory usage is something we have discussed as a target for improvement on ghcide. This info would allow us to correlate actions in the editor with spikes in memory usage, including exactly what data is taking up space. We could also check whether entries in this HashMap are released when appropriate, for example, when a file is closed.</p>
<h2 id="starting-out">Starting out</h2>
<p>The library only provides one <a href="https://hackage.haskell.org/package/ghc-datasize-0.2.2/docs/GHC-DataSize.html">module</a> with 3 functions. Of those, I only really needed <code>recursiveSize</code>. I set up a thread using the <a href="https://hackage.haskell.org/package/async">async</a> library to regularly run the <code>recursiveSize</code> function on the hashmap in question and print the result, the memory size of the hashmap, to stdout. The code compiled — a promising sign — but upon starting ghcide, I was greeted by the following error, and no size measurements.</p>
<pre><code>closurePtrs: Cannot handle type SMALL_MUT_ARR_PTRS_FROZEN_CLEAN yet</code></pre>
<p>Looking at the <code>recursiveSize</code> function showed nothing that could throw this error. I decided to dig a bit deeper at the functions it was calling, namely <code>closureSize</code> and <code>getClosureData</code> (which came from the <code>ghc-heap</code> library). The fact that both of them were calling a primop, <code>unpackClosure#</code>, seemed suspicious. I decided to grep for the error in GHC. Sure enough, this is an error message printed by <code>heap_view_closurePtrs</code> , a C function in the RTS, which is then used by the <code>unpackClosure#</code> primop.</p>
<p>This function works on <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/storage/heap-objects"><em>closures</em></a>, the objects that GHC’s RTS allocates on the heap to represent basically all Haskell values. When called on a haskell value, it inspects its closure’s tag, which determines what kind of data the closure is holding (e.g. a Thunk, different kinds of arrays, data constructors, etc.). Based on that it extracts the all the pointers contained in it. Back in haskell-land, <code>unpackClosure#</code> returns the objects pointed at by those pointers.</p>
<p>Looking through GHC’s git log showed that this function did not support any of the <code>SMALL_MUT_ARR_PTRS_*</code> closure types (corresponding to the <code>SmallArray#</code> and <code>SmallMutableArray#</code> types) until GHC 8.10. The library requires GHC 8.6 but looking at its code it seemed like it should work with a newer GHC. Given that the code is a single file, it seemed simple enough to just copy as-is into ghcide, which I did. Switching to GHC 8.10.1 stopped the error and showed some memory size measurements being printed. Success!</p>
<p>Except not so fast. Firstly, I was still getting a similar error:</p>
<pre><code>closurePtrs: Cannot handle type TVar
and
closurePtrs: Cannot handle type TSO</code></pre>
<p>It didn’t seem to stop the measuring thread, and it was also repeated. Looking back at the code for <code>heap_view_closurePtrs</code> it seems these closure types are not supported even in GHC 8.10. When it encounters them, <code>unpackClosure#</code> simply returns empty arrays, meaning that <code>recursiveSize</code> then just stops recursing and returns 0. I decided to ignore this error for now as there was a bigger issue.</p>
<p>It <em>appeared</em> that I was only getting an output 4-5 times after the start of the program. I assumed that some exception was stopping the thread that was performing the measurement. I was wrong. After an embarrassingly long time trying to find what could be throwing an exception, I realised: it wasn’t stopping, it was simply taking so long that I never saw the output because I just killed the program. Setting a recursion depth limit (having the measurement function stop recursing after a certain number of steps) made it keep on producing output confirming this hypothesis.</p>
<h2 id="this-time-it-is-a-bug-in-the-compiler-kind-of">This time it <em>is</em> a bug in the compiler (kind of)</h2>
<p>The recursion limit was not an acceptable workaround, as we would be missing the majority of the structure being measured. I decided to optimise enough that I could remove the recursion limit. I will not go into detail on the optimisations I did. Suffice it to say, I replaced a list of visited closure addresses that was used for cycle detection with a HashSet. What <em>is</em> important is that this optimisation allowed me to remove the recursion limit and uncovered a bug. I started getting this output, which appeared to also be fatal for the measuring thread:</p>
<pre><code>ghcide: internal error: allocation of 2243016 bytes too large (GHC should have complained at compile-time)
    (GHC version 8.10.1 for x86_64_unknown_linux)
    Please report this as a GHC bug:  https://www.haskell.org/ghc/reportabug</code></pre>
<p>My initial guess was that this was coming from the HashSet I had just added. I thought removing the recursion limit allowed it to get big enough to cause this error. However, some googling (and speaking with my GSoC mentor, Matthew) pointed to <a href="https://gitlab.haskell.org/ghc/ghc/-/issues/12492">this issue</a> which appeared like a much more plausible explanation. To save you a click, this is a bug in the <code>unpackClosure#</code> primop, used by <code>getClosureData</code> in <code>ghc-heap</code>, triggered when it is used on a closure above a certain size.</p>
<h2 id="patching-to-ghc">Patching to GHC</h2>
<p>This is the point where I decided to take a go at fixing this bug in GHC. I was initially hesitant. I had no clue about GHC’s internals at the time, but my mentors encouraged me to go ahead. The fact that this was a significant blocker for my project also helped.</p>
<h3 id="nailing-the-bug">Nailing the bug</h3>
<p>The first step was to make a minimal test case that would trigger the bug. I needed to make a closure <em>exactly</em> large enough to trigger this bug (but no bigger) and then call <code>unpackClosure#</code> on it. My first attempt used the <a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/GHC-IOArray.html#v:newIOArray"><code>newIOArray</code></a> function and then pattern matched on it to get the primitive array:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="dt">IOArray</span> (<span class="dt">STArray</span> _ _ _ arr)  <span class="ot">&lt;-</span> newIOArray (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">128893</span>) (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">let</span> <span class="fu">!</span>(<span class="fu">#</span> <span class="fu">!</span>_, _, _ <span class="fu">#</span>) <span class="fu">=</span> unpackClosure<span class="fu">#</span> (unsafeCoerce<span class="fu">#</span> arr)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  return ()</a></code></pre></div>
<p>The array size, which I found by experimentation, is the smallest that would trigger the bug. The call to <code>unpackClosure#</code> also needs to be pattern matched on, with those bang patterns, or the buggy code never runs (because of laziness).</p>
<p>I wanted to simplify this example the bit more, to the point of using primops exclusively. I thought that would also make it more obvious to someone reading the test what bug it is testing. This is the final test (and the one that is now in GHC’s test suite):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">main <span class="fu">=</span> <span class="dt">IO</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> newByteArray<span class="fu">#</span> <span class="dv">1032161</span><span class="fu">#</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  (<span class="fu">#</span> s&#39;, mba<span class="fu">#</span> <span class="fu">#</span>) <span class="ot">-&gt;</span> <span class="kw">case</span> unpackClosure<span class="fu">#</span> (unsafeCoerce<span class="fu">#</span> mba<span class="fu">#</span><span class="ot"> ::</span> <span class="dt">Any</span>) <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    (<span class="fu">#</span> <span class="fu">!</span>_, _, _ <span class="fu">#</span>) <span class="ot">-&gt;</span> (<span class="fu">#</span> s&#39;, () <span class="fu">#</span>)</a></code></pre></div>
<p>The major changes here are the use of <code>newByteArray#</code> instead of <code>newIOArray</code> and explicitly constructing an <code>IO ()</code> instead of using do-notation. The latter is a necessary for the former since <code>newByteArray#</code> returns an unlifted array (<code>MutableByteArray#</code>). You can also see that the array size has changed, since it is now in bytes, not a number of <code>Int</code>’s. However you might also notice that <span class="math inline">\(1032161\)</span> is not <em>exactly</em> <span class="math inline">\(8 * 128893\)</span>, which is what you would expect, since Ints should be 64 bits (8 bytes), but rather 1017 bytes more. I am unsure why this discrepancy is there but this was the minimum size that would trigger the bug.</p>
<h3 id="making-the-fix">Making the fix</h3>
<p>The information in this section might be inaccurate as I am new to all this. Please take it with a grain of salt.</p>
<p>I added this test case into GHC’s tests. The next step was to fix the actual bug. <code>unpackClosure#</code>, like all primops, is written in C–, a language used as an internal representation in GHC. There is excellent information on it <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/commentary/rts/cmm">in the GHC wiki</a>. There was a comment left on the ticket discussion that the problematic line had to be the following.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" data-line-number="1">ALLOC_PRIM_P (dat_arr_sz, stg_unpackClosurezh, closure);</a></code></pre></div>
<p>The previous line makes an allocation of <code>dat_arr_sz</code> words, which is then used by the next line:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" data-line-number="1">dat_arr = Hp - dat_arr_sz + WDS(<span class="dv">1</span>);</a></code></pre></div>
<p>Here <code>Hp</code> is the heap pointer. After calling <code>ALLOC_PRIM_P</code> it points to the top of the heap, and so we can get the pointer to the start of the array by subtracting the array size from the heap pointer.</p>
<p>According to the discussion on the issue, the fix to this would be to replace the use of <code>ALLOC_PRIM_P</code> with <code>allocate</code>. I was unsure of the right way to do this, but, thankfully, the <code>stg_newSmallArrayzh</code> function (mapping to the <code>newSmallArray#</code> primop) seemed to use <code>allocate</code> in essentially the same way as I needed. Copying the code from there and with some minor adaptations I got:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" data-line-number="1">(<span class="st">&quot;ptr&quot;</span> dat_arr) = ccall allocateMightFail(MyCapability() <span class="st">&quot;ptr&quot;</span>, BYTES_TO_WDS(dat_arr_sz));</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="cf">if</span> (dat_arr == NULL) (likely: False) {</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    jump stg_raisezh(base_GHCziIOziException_heapOverflow_closure);</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">}</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">TICK_ALLOC_PRIM(SIZEOF_StgArrBytes, WDS(len), <span class="dv">0</span>);</a></code></pre></div>
<p>Running the full test suite confirmed that this fixed the bug, and also did not cause any regressions. Job done! I got my commit history cleaned up and marked the MR as ready. It is now in the merge queue for GHC 8.12! (<a href="https://mail.haskell.org/pipermail/ghc-devs/2020-July/019083.html">or is it 9.0?</a>).</p>
<h2 id="back-to-the-main-task">Back to the main task</h2>
<p>At this point I was done with patching GHC, however I still needed the patched code for ghcide, using ghc 8.10. As it turns out, it is actually possible to define your own primops, in C–, include them in a Cabal package, and import them from Haskell using <code>foreign import prim</code>, which is what I ended up using. I forked ghc-datasize <a href="https://github.com/mpardalos/ghc-datasize">here</a>, and adapted it to work with a custom primop (containing this fix).</p>
<p>At this point I went back to running ghcide and realized that I needed to urgently improve the performance of ghc-datasize. Even with the optimisations I had already made, each measurement took almost 2 minutes! I am still in the process of optimising this library in order to make it practical for use on ghcide. However, one interesting turn in this process is the fact that I ended up throwing away the code I had written for use in GHC.</p>
<p>The purpose of the buggy allocation was to create an array to copy the closure’s data section into. I, however, had no use for this. I only needed the full size of the closure (in order to add to the final count) and its pointers (in order to recurse). Since I could get the closure size using <code>closureSize#</code> I could throw away the code dealing with the closure’s data section, including what I had previously added. This gave a 3-6x improvement in my benchmarks.</p>
<p>Even with this improvement, there is still work to be done before we can use this on ghcide. Measuring the HashMap I mentioned before, now takes around a minute and 30 seconds. This is a problem as it’s really hard to get valuable data on the running program if collection can only happen that rarely. This is something I am still working on and will hopefully write about once I’ve improved.</p>
<p>I have really enjoyed this process, especially since I go to understand so much about the internals of the language we all like using so much. Hopefully this post goes to show that taking your first steps in contributing to GHC can be very rewarding.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-07-10-ghc-libdir</title>
    <link href="http://mpickering.github.io//ide/posts/2020-07-10-ghc-libdir.html" />
    <id>http://mpickering.github.io//ide/posts/2020-07-10-ghc-libdir.html</id>
    <published>2020-07-24T00:00:00Z</published>
    <updated>2020-07-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Haskell Language Server, binaries and installation </h2>
<p class="text-muted">
    Posted on July 24, 2020 by <a href="https://github.com/bubba">Luke Lau</a>
    <span class="avatar"><img src="/ide/images/bubba.png"/></span>
</p>

<p>If you’ve ever had to install <em>haskell-ide-engine</em> or <em>haskell-language-server</em>, you might be aware that it is quite a lengthy process. There are several reasons for this, two of the most significant being:</p>
<ul>
<li>Both <em>haskell-ide-engine</em> and <em>haskell-language-server</em> act as a kitchen sink for plugins. These plugins all depend on the corresponding tool from Hackage, and as a result they end up pulling in <strong>a lot</strong> of transient dependencies.</li>
<li>The GHC API that powers the underlying <em>ghcide</em> session only works on projects that match <strong>the same</strong> GHC version as it was compiled with. This means that in order to support multiple GHC versions (which is quite common with Stack projects that can define a specific version of GHC) the install script needs to build a binary of <em>haskell-ide-engine</em>/<em>haskell-language-server</em> <strong>for every single GHC version</strong> that is supported.</li>
</ul>
<p>The latter is the purpose of the <em>hie-wrapper</em>/<em>haskell-language-server-wrapper</em> executable. The <code>install.hs</code> script will install binaries for every version under <code>haskell-language-server-8.6.5</code>, <code>haskell-language-server-8.8.3</code>, etc. The wrapper is then used in place of the language server, and will detect what version of GHC the project is using and launch the appropriate version of <em>hie</em>/<em>haskell-language-server</em>.</p>
<p>Building all these different binaries with several different versions of GHC means you need to build every single dependency multiple times over, leading to some hefty build times and chewing through a lot of disk space. On top of this, installation from source is the <em>only</em> supported installation method so far. This isn’t great for newcomers or for those who just want to setup a working IDE in a pinch. So many of us have spent the past month hard at work trying to improve the installation story.</p>
<h1 id="static-binaries">Static binaries</h1>
<p>One obvious solution would be to just provide static binaries. This has been a <a href="https://github.com/haskell/haskell-ide-engine/issues/1068">long running discussion</a>, that dates all the way back to <em>haskell-ide-engine</em>. When we say static binaries, we mean a binary that has no dynamically linked libraries. You can test that by running <code>ldd</code>:</p>
<pre><code>$ ldd haskell-language-server-wrapper
    linux-vdso.so.1 (0x00007fff185de000)
    libz.so.1 =&gt; /usr/lib/libz.so.1 (0x00007faa3a937000)
    libtinfo.so.5 =&gt; /usr/lib/libtinfo.so.5 (0x00007faa3a8d2000)
    librt.so.1 =&gt; /usr/lib/librt.so.1 (0x00007faa3a8c7000)
    libutil.so.1 =&gt; /usr/lib/libutil.so.1 (0x00007faa3a8c2000)
    libdl.so.2 =&gt; /usr/lib/libdl.so.2 (0x00007faa3a8bc000)
    libpthread.so.0 =&gt; /usr/lib/libpthread.so.0 (0x00007faa3a89a000)
    libgmp.so.10 =&gt; /usr/lib/libgmp.so.10 (0x00007faa3a7f7000)
    libm.so.6 =&gt; /usr/lib/libm.so.6 (0x00007faa3a6b2000)
    libc.so.6 =&gt; /usr/lib/libc.so.6 (0x00007faa3a4eb000)
    /lib64/ld-linux-x86-64.so.2 =&gt; /usr/lib64/ld-linux-x86-64.so.2 (0x00007faa3a9ab000)</code></pre>
<p>That’s a lot of linked libraries, all of which will need to be available on the users machine if we were just to ship the binary like that. With cabal-install, we can statically link these with just <code>cabal build --enable-exeutable-static</code>:</p>
<pre><code>$ ldd haskell-language-server-Linux-8.10.1 
	not a dynamic executable</code></pre>
<p>However one big caveat is that this only works on Linux. macOS doesn’t really have a notion of truly static binaries, since the system libraries are only provided as dylibs. The best we can do is just ensure that the only dynamically linked libraries are the ones already provided by the system, which it looks like it was in the first place!</p>
<pre><code>$ otool -L haskell-language-server
haskell-language-server:
	/usr/lib/libncurses.5.4.dylib (compatibility version 5.4.0, current version 5.4.0)
	/usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0)
	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1281.100.1)
	/usr/lib/libcharset.1.dylib (compatibility version 2.0.0, current version 2.0.0)</code></pre>
<h1 id="static-binaries-that-actually-work-on-other-machines">Static binaries that actually work on other machines</h1>
<p>Unfortunately, making a static binary is one thing, but having that binary be portable is another. If we want the binary to run on other machines outside of the host, it can’t rely on data-files, which some <a href="https://github.com/haskell/haskell-ide-engine/issues/1143">plugins such as <em>hlint</em> used</a>. And the same goes for any <code>libexec</code> binaries, which <em>cabal-helper</em> took advantage of.</p>
<p>Once these were <a href="https://github.com/ndmitchell/hlint/pull/824">taken care of upstream</a>, we then had to deal with GHC library directory: This is a directory that comes with your GHC installation, typically in something like <code>/usr/local/lib/ghc-8.10.1/</code> or in <code>~/.stack/programs/x86_64-osx/ghc-8.10.1/lib/ghc-8.10.1/</code> for Stack. Inside it contains all the compiled <a href="https://wiki.haskell.org/Library_submissions#The_Libraries">core libraries</a>, as well as the actual ghc executable itself: Your <code>/usr/bin/ghc</code> is most likely a script that just launches the binary in the library directory!</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">#!/bin/sh</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="va">exedir=</span><span class="st">&quot;/usr/local/lib/ghc-8.10.1/bin&quot;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="va">exeprog=</span><span class="st">&quot;ghc-stage2&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="va">executablename=</span><span class="st">&quot;</span><span class="va">$exedir</span><span class="st">/</span><span class="va">$exeprog</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="va">datadir=</span><span class="st">&quot;/usr/local/share&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="va">bindir=</span><span class="st">&quot;/usr/local/bin&quot;</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="va">topdir=</span><span class="st">&quot;/usr/local/lib/ghc-8.10.1&quot;</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="va">executablename=</span><span class="st">&quot;</span><span class="va">$exedir</span><span class="st">/ghc&quot;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="bu">exec</span> <span class="st">&quot;</span><span class="va">$executablename</span><span class="st">&quot;</span> -B<span class="st">&quot;</span><span class="va">$topdir</span><span class="st">&quot;</span> <span class="va">${1+</span><span class="st">&quot;</span><span class="va">$@</span><span class="st">&quot;</span><span class="va">}</span></a></code></pre></div>
<p>Either way, <em>ghcide</em>/<em>haskell-language-server</em> use the GHC API, which <a href="https://hackage.haskell.org/package/ghc-8.10.1/docs/GHC.html#v:runGhc">needs to know where this directory is</a> to do it’s job:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">runGhc ::</span> <span class="dt">Maybe</span> FilePath <span class="co">-- ^ The path to the library directory</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">                         <span class="co">-- Sometimes called the top_dir</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">       <span class="ot">-&gt;</span> <span class="dt">Ghc</span> a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">       <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a></code></pre></div>
<p>The most common way to get the path to the library directory is through the <a href="https://github.com/simonmar/ghc-paths/blob/master/Setup.hs"><em>ghc-paths</em></a> package, which uses <a href="https://github.com/simonmar/ghc-paths/blob/master/Setup.hs">some custom <code>Setup.hs</code> magic</a> to work out where the library directory is, for the GHC <strong>that is being used to compile the program</strong>. It bakes in the paths at compile time, which means it’s portable if we share the source and build it on other systems. But if we build it on one system where the library directory is at <code>/usr/local/lib/ghc-8.10.1</code> for example, then when <strong>distributing the binary</strong> to another system it will still try looking for the old path which resides on a completely different machine! For example, if GHC was installed via ghcup on the other system, then the library directory would reside at <code>~/.ghcup/ghc/8.10.1/lib/</code>: a very different location.</p>
<p>So if we want to be able to distribute these binaries and have them actually run on other systems, <em>ghc-paths</em> is out of the question. This means that we have to somehow get the library directory oureslves <strong>at runtime</strong>. Thankfully, the <code>ghc</code> executable has a handy command for this:</p>
<pre><code>$ ghc --print-libdir
/usr/local/lib/ghc-8.10.1</code></pre>
<p>We could just call this directly. But what if you had a Cabal project, configured with <code>cabal configure -wghc-8.8.3</code> whilst the <code>ghc</code> on your PATH was version 8.10.1? Then the library directories would have mismatching verisons! What we can do instead however is:</p>
<pre><code>$ cabal exec ghc -- --print-libdir
Resolving dependencies...
/usr/local/lib/ghc-8.8.3</code></pre>
<p>And consider even the case for Stack, where it downloads GHC for you. Well, we can do the same thing as Cabal:</p>
<pre><code>$ stack exec ghc -- --print-libdir
/Users/luke/.stack/programs/x86_64-osx/ghc-8.6.5/lib/ghc-8.6.5</code></pre>
<p>These commands are tool specific, so it only made perfect sense to put this logic into <a href="https://hackage.haskell.org/package/hie-bios"><em>hie-bios</em></a>, our library for interfacing and setting up GHC sessions with various tools. Now there’s an API for cradles to specify how to execute the <code>ghc</code> executable that they use when building themselves.</p>
<h1 id="automated-builds-with-github-actions">Automated builds with GitHub Actions</h1>
<p>The build process is automated across a wide range of platforms and GHC versions on GitHub Actions, which gets triggered everytime a release is made. Previously setting up Haskell on Travis CI/CircleCI/AppVeyor used to be pretty fiddly, but the <a href="https://github.com/actions/setup-haskell">setup-haskell</a> action for GitHub has made dramatic strides recently. In just a few lines of yaml we can setup a rather hefty build matrix for all the verisons we support:</p>
<pre><code>  build:
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        ghc: [&#39;8.10.1&#39;, &#39;8.8.3&#39;, &#39;8.8.2&#39;, &#39;8.6.5&#39;, &#39;8.6.4&#39;]
        os: [ubuntu-latest, macOS-latest, windows-latest]
        exclude:
          - os: windows-latest
            ghc: &#39;8.8.3&#39; # fails due to segfault
          - os: windows-latest
            ghc: &#39;8.8.2&#39; # fails due to error with Cabal</code></pre>
<p align="center">
<img alt="Now that's what I call a build matrix" src="/ide/images/github-actions-matrix.png" height="300"/>
</p>
<p>Unfortunately the story of Haskell on Windows is a bit hairy as usual, so there were a few bumps that needed worked around. The biggest and most annoying one by far was hitting the <code>MAX_PATH</code> limit for file paths whenever we tried to build the <code>haskell-language-server-wrapper</code> executable. Admittedly this is a rather long name for a binary, but a combination of the fact that GitHub actions checks out the source directory in <code>D:\a\haskell-language-server\haskell-language-server</code> and how Cabal’s per-component builds nest build products crazy deep meant that we we’re constantly going over the rather stringent 260 character limit:</p>
<pre><code>Linking D:\a\haskell-language-server\haskell-language-server\dist-newstyle\build\x86_64-windows\ghc-8.10.1\haskell-language-server-0.1.0.0\x\haskell-language-server-wrapper\build\haskell-language-server-wrapper\haskell-language-server-wrapper.exe ...
55
realgcc.exe: error: D:\a\haskell-language-server\haskell-language-server\dist-newstyle\build\x86_64-windows\ghc-8.10.1\haskell-language-server-0.1.0.0\x\haskell-language-server-wrapper\build\haskell-language-server-wrapper\haskell-language-server-wrapper-tmp\Paths_haskell_language_server.o: No such file or directory
56
`gcc.exe&#39; failed in phase `Linker&#39;. (Exit code: 1)</code></pre>
<p>We tried several things including</p>
<ul>
<li>Enabling the <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#enable-long-paths-in-windows-10-version-1607-and-later">LongPathsEnabled registry key</a> to disable this restriction. But it turns out it was already on the entire time and <a href="https://gitlab.haskell.org/ghc/ghc/issues/13373">GHC/GCC aren’t using the right Windows API calls</a></li>
<li>Checking out the code in a different root directory, but it doesn’t seem to be possible with GitHub actions</li>
<li>Squashing the build directory with just <code>--build-dir=b</code> – still left us 2 characters over the limit!</li>
<li>Disabling per-component builds – just fails with another build error</li>
</ul>
<p>But at the end of the day, the only reliable solution was just to rename <code>haskell-language-server-wrapper</code> to something shorter whilst building:</p>
<pre><code>- name: Shorten binary names
  shell: bash
  run: |
    sed -i.bak -e &#39;s/haskell-language-server/hls/g&#39; \
               -e &#39;s/haskell_language_server/hls/g&#39; \
               haskell-language-server.cabal
    sed -i.bak -e &#39;s/Paths_haskell_language_server/Paths_hls/g&#39; \
               src/**/*.hs exe/*.hs</code></pre>
<p>There’s still some sporadic issues with <a href="https://github.com/haskell/cabal/issues/6986">Cabal on Windows</a> and GitHub Actions having infrastructure outages so the builds aren’t 100% flake free yet, but it does provide a rather large build matrix with generous amounts of parallelism. <a href="https://github.com/haskell/haskell-language-server/releases/tag/0.2.1">You can check out the first release with binaries here.</a></p>
<h1 id="the-new-haskell-visual-studio-code-extension">The new Haskell Visual Studio Code extension</h1>
<p>So you can download the binaries and manually put them on your path, which is fine and dandy, but at the end of the day the ultimate goal was to make the process of setting up a Haskell environment as easy as possible for newcomers. So now the Visual Studio Code now takes full advantage of these binaries by <em>automatically downloading them</em>.</p>
<p>It first downloads the wrapper, which it can use to detect what GHC version the project is using. Then once it knows what GHC your project needs, it downloads the appropriate <code>haskell-language-server</code> for the matching GHC and platform before spinning it up. That way you only need the binaries for the GHC versions you are using, and the extension will automatically download the latest binaries whenever a new version of <code>haskell-language-server</code> is released. The video below shows it in action:</p>
<video controls alt="Visual Studio Code demo" style="width: 100%" src="/ide/images/vscode-demo.mov" />
<p>Hopefully this one click install will help users get setup a lot more quickly, but it is worth noting that at either GHC, Cabal or Stack still need to be installed depending on the project. They’re needed for both the aforementioned GHC library directory, as well as building dependencies etc. (But someday in the near future, we might be able to automatically download these tools as well!)</p>
<p>In the coming weeks the Visual Studio Code extension, previously known as <code>vscode-hie-server</code>, will be hosted under the Haskell organisation and become just “Haskell” in the extension marketplace. This should give a new unified, official front for the language server, which is a labour of love of the entire community: The road to these static binaries was the work of many contributors across ghcide, hie-bios and haskell-language-server. Thanks to Javier Neira for ironing out all the kinks on Windows, Brian McKenna and amesgen for making the binaries truly static on Linux, and <a href="https://github.com/haskell/haskell-language-server/issues/158">all those who helped test it out</a>.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-07-17-hls-update</title>
    <link href="http://mpickering.github.io//ide/posts/2020-07-17-hls-update.html" />
    <id>http://mpickering.github.io//ide/posts/2020-07-17-hls-update.html</id>
    <published>2020-07-17T00:00:00Z</published>
    <updated>2020-07-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Haskell Language Server 0.2.0 </h2>
<p class="text-muted">
    Posted on July 17, 2020 by <a href="https://github.com/fendor">Fendor</a>
    <span class="avatar"><img src="/ide/images/fendor.png"/></span>
</p>

<p>We are back for another update of this summer’s Haskell IDE efforts. Quite some time has passed since our last update, so we have a lot to tell you about! We are going to speak about what is new in the latest release and what other new features are already waiting in the pipeline.</p>
<h2 id="release-haskell-language-server-0.2.0">Release Haskell Language Server 0.2.0</h2>
<p>At the start of this month we released a new version of Haskell Language Server! The ChangeLog is <a href="https://github.com/haskell/haskell-language-server/blob/master/ChangeLog.md#02">huge</a> since the last release was quite some time ago! While a lot of these changes are minor, e.g. fix some bug, bump some dependency version, there are also new features! Most of the new features are added to the project <a href="https://github.com/digital-asset/ghcide">ghcide</a> which we rely on, so they actually dont show up in the ChangeLog.</p>
<h3 id="delete-unused-function-definition">Delete unused function definition</h3>
<p>There is now a new code-action which allows deletion of unused top-level bindings! To trigger this code-action, you need to enable the warning <code>-Wunused-top-binds</code> in your project. For <code>cabal</code> and <code>stack</code>, you can enable it for your library by modifying your <code>*.cabal</code> file:</p>
<pre><code>library
   ...
   ghc-options: -Wunused-top-binds</code></pre>
<p>Note, that this warning is implied by <code>-Wall</code>, which you should always use to compile your project!</p>
<p>A big thank you to @serhiip for implementing this nice code-action!</p>
<h3 id="add-typeclass-constraint-to-function-declaration">Add Typeclass Constraint to function declaration</h3>
<p>Another awesome addition that will especially help newcomers: Add a missing typeclass constraint!</p>
<p>Take this imaginary example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> a <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">equal ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">equal (<span class="dt">Leaf</span> x) (<span class="dt">Leaf</span> y) <span class="fu">=</span> x <span class="fu">==</span> y</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">equal (<span class="dt">Node</span> x y) (<span class="dt">Node</span> m n) <span class="fu">=</span> equal x y <span class="fu">&amp;&amp;</span> equal m n</a></code></pre></div>
<p>We essentially just want to check that our trees are structurally identical, but, unfortunately, we forgot to add the constraint <code>Eq a</code> to the head of our function definition.</p>
<p>The fix is just two clicks away:</p>
<figure>
<img src="https://i.imgur.com/TfOqBgI.gif" alt="A cute GIF about adding a typeclass constraint" /><figcaption>A cute GIF about adding a typeclass constraint</figcaption>
</figure>
<p>Thanks to @DenisFrezzato, who implemented this feature.</p>
<h3 id="various-performance-improvements">Various performance improvements</h3>
<p>This section is a bit vague, but going into more details would be out of the scope of this blogpost.</p>
<p>Here is a brief summary:</p>
<ul>
<li>A name cache for <code>*.HIE</code> files has been added. This ought to power future features such as <code>Go to Type Definition</code>, <code>Go to References</code> and similar.</li>
<li>Avoid excessive retypechecking of TH codebases.</li>
<li>Performance improvements for GetSpanInfo.</li>
</ul>
<p>Also, not to forget all the performance improvements from previous blogposts that have been merged into upstream repositories step by step.</p>
<p>With all of these, the overall experience ought to be a little bit smoother than before.</p>
<h2 id="upcoming-features">Upcoming Features</h2>
<p>It is always a bit tricky to talk about new features before they are released. There can always be last minute changes or delays and everyone is let down if a feature isn’t in the next release. This is frustrating for us too!</p>
<p>Nevertheless, I will tease some upcoming improvements, with a disclaimer, that we cannot promise that the features will make it into the next release.</p>
<h3 id="prebuilt-binaries">Prebuilt Binaries</h3>
<p>This has been a long requested feature! The first issue I can find about it was created for Haskell IDE Engine in January 2019. Back then, Haskell IDE Engine was facing a number of road blocks, such as data-files that are not easily relocatable and reliance on packages such as <code>ghc-paths</code> which compile important run-time information into the binary. Piece by piece, these issues have been resolved by patching upstream libraries, using alternative APIs and querying the run-time information at, well, run-time. Major changes to <a href="https://github.com/mpickering/hie-bios/">hie-bios</a> were necessary in order to make it possible to find the information we care about.</p>
<p>Now we are close to being able to offer pre-built binaries for Windows, macOS and Linux.</p>
<p>A natural extension of this will be to make it possible to download these binaries from your editor extension. This is also in the making, although, for now, only for the vscode extension <code>vscode-hie-server</code>. With prebuilt binaries, we hope to make the setup experience for newcomers easier and faster, without the need to compile everything from scratch, which can take hours and hours.</p>
<p>As the cherry on top, we plan to integrate these pre-built binaries with the successful tool <a href="https://www.haskell.org/ghcup/">ghcup</a>. This will improve the tooling story for Haskell and setting up from zero to a full-blown development environment will be a matter of minutes.</p>
<h3 id="simple-eval-plugin">Simple Eval Plugin</h3>
<p>A new plugin called “Eval” will be added soon to the Haskell Language Server! Its purpose is to automatically execute code in haddock comments to make sure that example code is up-to-date to the actual implementation of the function. This does not replace a proper CI, nor <a href="https://github.com/sol/doctest#readme">doctest</a>, but it is a simple quality of life improvement!</p>
<p>For example, assume the following piece of code:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">T4</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span> (unwords)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">-- &gt;&gt;&gt; let evaluation = &quot; evaluation&quot;</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">-- &gt;&gt;&gt; unwords example ++ evaluation</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="ot">example ::</span> [<span class="dt">String</span>]</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">example <span class="fu">=</span> [<span class="st">&quot;This&quot;</span>,<span class="st">&quot;is&quot;</span>,<span class="st">&quot;an&quot;</span>,<span class="st">&quot;example&quot;</span>,<span class="st">&quot;of&quot;</span>]</a></code></pre></div>
<p>Executing these haddock code-examples by hand is a bit tedious. It is way easier to just execute a <em>code lens</em> and see the result. With the “Eval” plugin, it is as easy as a single click to produce the relevant output:</p>
<figure>
<img src="https://i.imgur.com/raaTFKr.gif" alt="Evaluate Haddock code comment" /><figcaption>Evaluate Haddock code comment</figcaption>
</figure>
<p>And as promised, changes to any of the relevant definitions are picked up and we can update our haddock example:</p>
<figure>
<img src="https://i.imgur.com/G6WbAQd.gif" alt="Update Haddock code comment" /><figcaption>Update Haddock code comment</figcaption>
</figure>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-06-12-performance-of-ghcide-020</title>
    <link href="http://mpickering.github.io//ide/posts/2020-06-12-performance-of-ghcide-020.html" />
    <id>http://mpickering.github.io//ide/posts/2020-06-12-performance-of-ghcide-020.html</id>
    <published>2020-06-12T00:00:00Z</published>
    <updated>2020-06-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> The performance of ghcide 0.2.0 </h2>
<p class="text-muted">
    Posted on June 12, 2020 by <a href="https://github.com/pepeiborra">Pepe Iborra</a>
    <span class="avatar"><img src="/ide/images/pepeiborra.png"/></span>
</p>

<p>You may have tried <em>ghcide</em> in the past and given up after running out of memory. If this was your experience, you should be aware that <em>ghcide</em> v0.2.0 was released <a href="https://twitter.com/cocreature/status/1267837792064876545?s=20">earlier this month</a> with a number of very noticeable efficiency improvements. Perhaps after reading this post you will consider giving it another try.</p>
<p>In case you don’t have time much, this is what the heap size looks like while working on the Cabal project (230 modules) over different versions of <em>ghcide</em>:</p>
<figure>
<img src="/ide/images/hoverAfterEdit-majorVersions.svg" alt="ghcide heap size while working on Cabal" /><figcaption>ghcide heap size while working on Cabal</figcaption>
</figure>
<p>The graph shows that <em>ghcide</em> v0.2.0 is much more frugal and doesn’t’ leak. These improvements apply to haskell-language-server as well, which builds on a version of <em>ghcide</em> that includes these benefits.</p>
<h2 id="background">Background</h2>
<p>A few months ago I started using <em>ghcide</em> 0.0.6. It worked fine for small packages, but our codebase at work has a few hundreds of modules and <em>ghcide</em> would happily grow &gt;50GB of RAM. While the development server I was using had RAM to spare, the generation 1 garbage collector pauses were multi-second and making <em>ghcide</em> unresponsive. Thus one of my early contributions to the project was to use <a href="https://github.com/digital-asset/ghcide/pull/329">better default GC settings</a> to great effect.</p>
<p>Work to improve the situation started during the <a href="https://mpickering.github.io/bristol2020.html">Bristol Hackathon</a> that Matthew Pickering organised, where some of us set to teach <em>ghcide</em> to leverage <code>.hi</code> and <code>.hie</code> files produced by GHC to reduce the memory usage. Version 0.2.0 is the culmination of those efforts, allowing it to handle much larger projects with ease.</p>
<p>In parallel, Matthew Pickering and Neil Mitchell spent some long hours chasing and plugging a number of space leaks that were causing an unbounded memory growth while editing files or requesting hover data. While there’s probably still some leaks left, the situation has improved dramatically with the new release.</p>
<h2 id="benchmarks">Benchmarks</h2>
<p>One thing that became clear recently is that a benchmark suite is needed, both to better understand the performance impact of a change and to prevent the introduction of space leaks that are very costly to diagnose once they get in.</p>
<p>Usually the main hurdle with defining a benchmark suite is ensuring that the experiments do reproduce faithfully the real world scenario that is being analysed. Thankfully, the fantastic lsp-test package makes this relatively easy in this case. An experiment in the new and shiny <em>ghcide</em> benchmark suite looks like follows:</p>
<p>
<script src="https://gist-it.appspot.com/http://github.com/pepeiborra/ghcide/blob/144837aa90b75f8dab5a8e639369b5ca1fba6e66/bench/Main.hs?slice=103:106"></script>
</p>
<p>Currently the benchmark suite has the following experiments covering the most common actions:</p>
<pre><code>- edit
- hover
- hover after edit
- getDefinition
- completions after edit
- code actions
- code actions after edit
- documentSymbols after edit</code></pre>
<p>The benchmark unpacks the Cabal 3.0.0.0 package (using Cabal of course), then starts <em>ghcide</em> and uses Luke’s lsp-test package to simulate opening the <code>Distribution.Version</code> module and repeating the experiment a fixed number of times, collecting time and space metrics along the way. It’s not using criterion or anything sophisticated yet, so there is plenty of margin for improvement. But at least it provides a tool to detect performance regressions as well as to decide which improvements are worth pursuing.</p>
<h2 id="performance-over-time">Performance over time</h2>
<p>Now that we have a standard set of experiments, we can give an answer to the question:</p>
<blockquote>
<p>How did the performance change since the previous release of <em>ghcide</em>?</p>
</blockquote>
<p>Glad that you asked!</p>
<p>I have put together a little Shake script to checkout, benchmark and compare a set of git commit ids automatically. It is able to produce simple graphs of memory usage over time too. I have used it to generate all the graphs included in this blog post, and to gain insights about the performance of <em>ghcide</em> over time that have already led to new performance improvements, as explained in the section about interfaces a few lines below.</p>
<p>The script is currently still in <a href="https://github.com/digital-asset/ghcide/pull/629">pull request</a>.</p>
<h2 id="performance-of-past-ghcide-versions">Performance of past ghcide versions</h2>
<p>The graph of live bytes over time shown at the beginning of the post was for the hover after edit experiment. It’s reproduced below for convenience.</p>
<figure>
<img src="/ide/images/hoverAfterEdit-majorVersions.svg" alt="ghcide heap size while working on Cabal" /><figcaption>ghcide heap size while working on Cabal</figcaption>
</figure>
<p>The graph shows very clearly that versions 0.0.5, 0.0.6 and 0.1.0 of <em>ghcide</em> contained a roughly constant space leak that caused the huge memory usage that caused many people including myself struggle with <em>ghcide</em>. As <em>ghcide</em> became faster in v0.1.0 the leak became faster too, making the situation perhaps even worse.</p>
<p>The good news is that not only does v0.2.0 leak nearly zero bytes in this experiment, but it also sits at a much lower memory footprint. Gone are the days of renting EC2 16xlarge instances just to be able to run <em>ghcide</em> in your project!</p>
<p>The graph also shows that v0.1.0 became 2.5X faster than the previous version, whereas v0.2.0 regressed in speed by a roughly similar amount. I wasn’t aware of this fact before running these experiments, and I don’t think any of the usual <em>ghcide</em> contributors was either. By pointing the performance over time script to a bunch of commits in between the 0.1.0 and 0.2.0 version tags, it was relatively easy to track this regression down to the change that introduced interface files. More details a few lines below.</p>
<h2 id="the-hashmap-space-leak">The HashMap space leak</h2>
<p>The graph below compares the live bytes over time in the hover after edit experiment before and after <a href="https://github.com/digital-asset/ghcide/pull/588">Neil’s PR</a> fixing the ‘Hashable’ instances to avoid a space leak on collisions.</p>
<figure>
<img src="/ide/images/hoverAfterEdit-hashablePR.svg" alt="ghcide heap size before and after HashMap space leak fix" /><figcaption>ghcide heap size before and after HashMap space leak fix</figcaption>
</figure>
<p>The graph shows clearly that the fix makes a huge difference in the memory footprint, but back when Neil sent his PR, the benefits were not so obvious. Neil said at the time:</p>
<blockquote>
<p>This patch and the haskell-lsp-types one should definitely show up in a benchmark, if we had one. Likely on the order of 2-10%, given the profiling I did, but given how profiling adjusts times, very hard to predict. Agreed, without a benchmark its hard to say for sure.</p>
</blockquote>
<p>And then followed up with:</p>
<blockquote>
<p>Since I had the benchmark around I ran it. 9.10s, in comparison to 9.77s before.</p>
</blockquote>
<p>That statement doesn’t really illustrate the massive space benefits of this fix. A good benchmark suite must show not only time but also space metrics, which are often just as important or even more.</p>
<h2 id="the-switch-to-interfaces">The switch to interfaces</h2>
<p><em>ghcide</em> versions prior to 0.2.0 would load, parse and typecheck all the dependencies of a module, and then cache those in memory for the rest of the session. That’s very wasteful given that <em>GHC</em> supports separate compilation to avoid exactly this, writing a so called “interface” or <code>.hi</code> file down to disk with the results of parsing and typechecking a module. And indeed, <em>GHCi</em>, <em>ghcid</em> and other build tools including <em>GHC</em> itself leverage these interface files to avoid re-typechecking a module unless it’s strictly necessary. In version 0.2.0 we have rearranged some of the internals to take advantage of interface files for typechecking and other tasks: if an interface file is available and up-to-date it will be reused, otherwise the module is typechecked and a new interface file is generated. 0.2.0 also leverages extended interface (<code>.hie</code>) files for similar purposes.</p>
<p>The graph below shows the accumulated impact of the switch to interface files, which was spread over several PRs for ease of review, using the get definition experiment compared with the previous version:</p>
<figure>
<img src="https://raw.githubusercontent.com/pepeiborra/ghcide/bench-hist-dump/bench-hist/interface_files/getDefinition.diff.svg" alt="ghcide heap size before and after interface files (get definition)" /><figcaption>ghcide heap size before and after interface files (get definition)</figcaption>
</figure>
<p>On a first impression this looks like a net win: shorter execution time and lower memory usage, as one would expect from such a change. But when we look at another experiment, hover after edit, the tables turn as the experiment takes almost twice as long as previously, while consuming even more memory:</p>
<figure>
<img src="https://raw.githubusercontent.com/pepeiborra/ghcide/bench-hist-dump/bench-hist/interface_files/hover_after_edit.diff.svg" alt="ghcide heap size before and after interface files (hover after edit)" /><figcaption>ghcide heap size before and after interface files (hover after edit)</figcaption>
</figure>
<p>We can explain the memory usage as the result of a space leak undoing any win from using interface files, but there is no such explanation for the loss in performance. This is a good reminder that one experiment is not enough, a good benchmark suite must cover all the relevant use cases, or as many as possible and practical.</p>
<p>As it turns out, the switch to interfaces introduced a serious performance regression in the code that collects the Haddocks for the set of spans of a module, something that went completely undetected until now. Thankfully, with the knowledge that better performance is available, it is much easier for any competent programmer to stare at their screen comparing, measuring and bisecting until eventually such performance is recovered. This <a href="https://github.com/digital-asset/ghcide/pull/630">pull request</a> to ghcide does so for this particular performance regression.</p>
<h2 id="conclusion">Conclusion</h2>
<p><em>ghcide</em> is a very young project with plenty of low hanging fruit for the catch. With a benchmark suite in place, the project is now in a better position to accept contributions without the fear of incurring into performance regressions or introducing new space leaks.</p>
<p>If you are interested in joining a very actively developed Haskell project, check the good first issue tags for <a href="https://github.com/digital-asset/ghcide/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">ghcide</a> and <a href="https://github.com/haskell/haskell-language-server/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">haskell-language-server</a> and send your contributions for review!</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-06-05-ghcide-and-nixpkgs</title>
    <link href="http://mpickering.github.io//ide/posts/2020-06-05-ghcide-and-nixpkgs.html" />
    <id>http://mpickering.github.io//ide/posts/2020-06-05-ghcide-and-nixpkgs.html</id>
    <published>2020-06-05T00:00:00Z</published>
    <updated>2020-06-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Getting ghcide into nixpkgs </h2>
<p class="text-muted">
    Posted on June  5, 2020 by <a href="https://github.com/maralorn">Malte Brandy</a>
    <span class="avatar"><img src="/ide/images/maralorn.png"/></span>
</p>

<p>A few weeks ago I got <a href="https://github.com/digital-asset/ghcide">ghcide</a> into <a href="https://nixos.org/nixos">nixpkgs, the package set of the package manager nix and the distribution nixos</a>. Mind you, that was not a brave act of heroism or dark wizardry. Once I grasped the structure of the nixpkgs Haskell ecosystem, it was actually pretty easy. In this post I want to share my experience and tell you what I learned about the nixpkgs Haskell infrastructure and ghcide.</p>
<p>This post has four parts:</p>
<ol type="1">
<li>Why can installing ghcide go wrong?</li>
<li>How can you install ghcide on nix today?</li>
<li>The nixpkgs Haskell ecosystem and dependency resolution</li>
<li>How ghcide got fixed in nixpkgs</li>
</ol>
<!--more-->
<h2 id="why-can-installing-ghcide-go-wrong">1. Why can installing ghcide go wrong?</h2>
<p>Haskell development tooling setup is infamous for being brittle and hard to setup. Every other day when someone asks on reddit or in the <code>#haskell</code> channel, inescapably there will come at least one answer of the form “It’s not worth the pain. Just use ghcid.” I guess one point of this blog series is that this does not have to be the case anymore.</p>
<p>So, what were the reasons for this resignation? One is certainly that <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a> is a really great and easy to use tool. I think it‘s clear that a well done language server can leverage you much further and to me <code>ghcide</code> has already proven this.</p>
<h3 id="compile-your-project-and-ghcide-with-the-same-ghc">Compile your project and ghcide with the same ghc!</h3>
<p>One source of frustration is likely that successfully setting up a language server that is deeply interwoven with <code>ghc</code> like <code>ghcide</code> has one very important requirement. <strong>You need to compile <code>ghcide</code> with the same <code>ghc</code> (version) as your project.</strong> This shouldn‘t be hard to achieve nowadays - I’ll show how to do it if you use <code>nix</code> in this blogpost and I assume it‘s the default in other setups - but if you fail to meet this requirement you are in for a lot of trouble.</p>
<p>So why exactly do we need to use “the same ghc” and what does that even mean? Frankly I am not totally sure. I am not a <code>ghcide</code> developer. I guess sometimes you can get away with some slight deviations, but the general recommendation is to use the same <code>ghc</code> version. I can tell you three situations that will cause problems or have caused problems for me:</p>
<ol type="1">
<li><p>Using another <code>ghc</code> release. E.g. using <code>ghcide</code> compiled with <code>ghc</code> 8.8 on a <code>ghc</code> 8.6 project I get:</p>
<pre class="plain"><code>Step 4/6, Cradle 1/1: Loading GHC Session
ghcide: /nix/store/3ybbc3vag4mpwaqglpdac4v413na3vhl-ghc-8.6.5/lib/ghc-8.6.5/ghc-prim-0.5.3/HSghc-prim-0.5.3.o: unknown symbol `stg_atomicModifyMutVarzh&#39;
ghcide: ghcide: unable to load package `ghc-prim-0.5.3&#39;</code></pre></li>
<li><p>Using the same <code>ghc</code> version but linked against different external libraries like <code>glibc</code>. This <a href="https://github.com/digital-asset/ghcide/issues/404">can happen</a> when <a href="https://github.com/digital-asset/ghcide/issues/538">different releases</a> of nixpkgs are involved. This could look like this:</p>
<pre class="plain"><code>Step 4/6, Cradle 1/1: Loading GHC Session
ghcide: &lt;command line&gt;: can&#39;t load .so/.DLL for: /nix/store/hz3nwwc0k32ygvjn63gw8gm0nf9gprd8-ghc-8.6.5/lib/ghc-8.6.5/ghc-prim-0.5.3/libHSghc-prim-0.5.3-ghc8.6.5.so (/nix/store/6yaj6n8l925xxfbcd65gzqx3dz7idrnn-glibc-2.27/lib/libm.so.6: version `GLIBC_2.29&#39; not found (required by /nix/store/hz3nwwc0k32ygvjn63gw8gm0nf9gprd8-ghc-8.6.5/lib/ghc-8.6.5/ghc-prim-0.5.3/libHSghc-prim-0.5.3-ghc8.6.5.so))</code></pre>
<p>or like this</p></li>
</ol>
<pre class="plain"><code>   Unexpected usage error
   can&#39;t load .so/.DLL for: /nix/store/pnd2kl27sag76h23wa5kl95a76n3k9i3-glibc-2.27/lib/libpthread.so
   (/nix/store/pnd2kl27sag76h23wa5kl95a76n3k9i3-glibc-2.27/lib/libpthread.so.0: undefined symbol:
   __libc_vfork, version GLIBC_PRIVATE)</code></pre>
<ol start="3" type="1">
<li>Using the same <code>ghc</code> release but with a patch to <code>ghc</code>. This e.g. happened to me while using the <a href="https://github.com/obsidiansystems/obelisk"><code>obelisk</code> framework</a> which uses a modified <code>ghc</code>.</li>
</ol>
<p>To sum up, both ghcs should come from the same source and be linked against the same libraries. Your best bet is to use the same binary. But that is not necessary.</p>
<h2 id="how-can-you-install-ghcide-on-nix-today">2. How can you install ghcide on nix today?</h2>
<p>When you want to use <code>ghcide</code> with nix you now have two options. Either <a href="https://nixos.org/nixos/packages.html?query=ghcide"><code>haskellPackages.ghcide</code></a> from nixpkgs or <a href="https://github.com/cachix/ghcide-nix"><code>ghcide-nix</code></a> which uses the <a href="https://github.com/input-output-hk/haskell.nix"><code>haskell.nix</code> ecosystem</a>. I will describe both solutions and their pros and cons from my point of view.</p>
<h3 id="haskellpackages.ghcide">haskellPackages.ghcide</h3>
<p>First make sure you are on a new enough version of nixpkgs. You can try installing <code>ghcide</code> user or system wide, with e.g. <code>nix-env -iA haskellPackages.ghcide</code> or via your <code>configuration.nix</code> on nixos. But that has a greater danger of being incompatible with the <code>ghc</code> you are using in your specific project. The less brittle and more versatile way is to configure <code>ghcide</code> in your projects <code>shell.nix</code>. You probably already have a list with other dev tools you use in there, like <code>with haskellPackages; [ hlint brittany ghcide ]</code>. Just add <code>ghcide</code> in that list and you are good to go. See e.g. <a href="https://discourse.nixos.org/t/nix-haskell-development-2020/6170">this post for a recent discussion about a Haskell dev setup with nix</a>. If you are stuck with an old nixpkgs version, have a look at the end of part 4.</p>
<h4 id="pros">Pros</h4>
<ul>
<li>Easy to setup</li>
<li>Builds ghcide with the same ghc binary as your project, so no danger of incompatabilities between ghc and ghcide.</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>We only have released versions of ghcide in nixpkgs. If you use nixpkgs-stable it might not even be the last release.</li>
<li>When you use another <code>ghc</code> version than the default in your nixpkgs version, nix will compile ghcide on your computer because it isn‘t build by hydra. (build times are totally fine though.)</li>
</ul>
<h3 id="ghcide-nix">ghcide-nix</h3>
<p>You can import the <code>ghcide-nix</code> repo as a derivation and install the ghcide from there. Consult the README for more details.</p>
<h4 id="pros-1">Pros</h4>
<ul>
<li>Cached binaries for all supported <code>ghc</code> versions via cachix.</li>
<li>Always a recent version from the ghcide master branch.</li>
<li>Definitely recommended when you are already using the <code>haskell.nix</code> infrastructure for your project.</li>
</ul>
<h4 id="cons-1">Cons</h4>
<ul>
<li>Danger of incompatibilities, when your nixpkgs version and the pinned one of <code>ghcide-nix</code> don‘t match.</li>
<li>Not compatible with a patched ghc, which is not build for the <code>haskell.nix</code> infrastructure.</li>
<li>Larger nix store closure.</li>
</ul>
<p><strong>EDIT:</strong> I have been made aware of an alternative method to install <code>ghcide</code> with <code>haskell.nix</code>:</p>
<blockquote>
<p>you can add it to a haskell.nix shell (one created with the <code>shellFor</code> function) with <code>x.shellFor { tools = { ghcide = &quot;0.2.0&quot;; }; }</code>. This will build <code>ghcide</code> with the <code>ghc</code> version in the shell.</p>
</blockquote>
<p>Have a look at the <code>haskell.nix</code> documentation for more details.</p>
<h3 id="configuration-and-setup">Configuration and Setup</h3>
<p>Of course, after installing you need to test <code>ghcide</code> and possible write a <code>hie.yaml</code> file to get <code>ghcide</code> to work with a specific project. This is not very nix specific and will probably change in the future, so I don‘t dive into it right now. Consult the readmes of <a href="https://github.com/digital-asset/ghcide"><code>ghcide</code></a> and <a href="https://github.com/mpickering/hie-bios"><code>hie-bios</code></a>.</p>
<p>There is though one point to note here and that is package discovery. <code>ghcide</code> needs to know all the places that <code>ghc</code> uses to lookup dependencies. When (and I think only when) you use the <code>ghc.withPackages</code> function from <code>nixpkgs</code> the dependencies are provided to <code>ghc</code> via environment variables set in a wrapper script. In general <code>ghcide</code> will not know about this variables and fail to find dependencies. E.g.:</p>
<pre><code>Step 4/6, Cradle 1/2: Loading GHC Session
ghcide: &lt;command line&gt;: cannot satisfy -package-id aeson-1.4.7.1-5lFE4NI0VYBHwz75Ema9FX</code></pre>
<p>To prevent this you need to find a way to set those environment variables when starting <code>ghcide</code>. <a href="https://github.com/NixOS/nixpkgs/pull/89450">I have a PR underway</a> which should do this for you if you install <code>ghcide</code> by putting it in the same <code>withPackages</code> list.</p>
<h2 id="the-nixpkgs-haskell-ecosytem-and-dependency-resolution">3. The nixpkgs Haskell ecosytem and dependency resolution</h2>
<p>This section might be slightly off-topic here, so feel free to skip it. I think this is really useful to know if you work with Haskell and nixpkgs and I regard it as necessary context to understand the fix outlined in part 4.</p>
<h3 id="haskell-dependency-resolution-in-general">Haskell dependency resolution in general</h3>
<p>Dependency resolution problems have a long history in Haskell, but today there are two solutions that both work quite well in general.</p>
<ol type="1">
<li>Specify upper and lower bounds for every dependency in your cabal file and let cabal figure out a build plan. The times of cabal hell are over and this works quite well. Notably this is the way ghcide is supposed to be compiled in general.</li>
<li>Pin a stack LTS release for your dependencies and pin the version for packages not on stackage.</li>
</ol>
<p>Now solution two is in some sense less complex to use, because at compile time you don‘t need to construct a build plan. Of course, as I said, today cabal can do this for you very smoothly, which is why I personally prefer the first approach.</p>
<h3 id="haskell-in-nixpkgs---pkgs.hackagepackages">Haskell in nixpkgs - pkgs.hackagePackages</h3>
<p>So how does nixpkgs do it? Well basically solution two. Everyday <a href="https://github.com/NixOS/nixpkgs/commit/0a566a5777264e58fbfc259cb6453a9685dc5bfb">a cronjob</a> pulls a list of <strong>all packages from a pinned stack LTS release</strong> and creates a derivation for every one of them. It also pulls <strong>all other packages from hackage</strong> and creates a derivation for the <strong>latest released version</strong> of them. (This happens on the <a href="https://github.com/NixOS/nixpkgs/compare/haskell-updates">haskell-updates branch of nixpkgs</a> which get‘s normally merged into nixpkgs master i.e. unstable <a href="https://github.com/NixOS/nixpkgs/pull/88894">once per week</a>. So then, you ask, how does cabal2nix do dependency resolution? Well the short form is, it doesn‘t. What I mean by that is: It completely ignores any version bounds given in a cabal file or a pinned stack LTS release. It will just <strong>take the one version of every dependency that is present in nixpkgs</strong> by the method I told you above.</p>
<p>When I first learned about this I thought this was ludicrous. This is prone to fail. And indeed it does. For a large number of packages the build will either fail at compile time or more often cabal will complain that it can‘t create a build plan. What that actually means: cabal says the one build plan we provided it with is invalid because it does not match the given version bounds. duh. So that packages get automatically marked broken after hydra, the nixos build server, fails to build them. And oh boy, <a href="https://github.com/NixOS/nixpkgs/blob/0a566a5777264e58fbfc259cb6453a9685dc5bfb/pkgs/development/haskell-modules/configuration-hackage2nix.yaml#L2647-L10970">there are a lot of Haskell packages broken in nixpkgs</a>.</p>
<p>Before grasping how this setup comes together, <a href="https://discourse.nixos.org/t/nix-and-the-haskell-eco-system-a-match-made-in-heaven-or-a-difficult-relationship/3314">I was very frustrated by this</a>. And I guess for others casually encountering broken Haskell packages in nixpkgs, without understanding this setup can be annoying.</p>
<p>What could be a suitable alternative to this for nixpkgs? Tough to say. We could try to use some solution like the go, rust or node ecosystem and check in a build plan for every package. Actually that can be a nice solution and if you are interested in that you should definitely checkout the <code>haskell.nix</code> infrastructure. But that really does not go well together with providing all of hackage in nixpkgs. For starters having every version of every Haskell package in nixpkgs would already be very verbose. And Haskell dependency resolution is structured in a way that in one build all dependencies have to agree on the version of mutual further dependencies. That means two build plans that use the same version of one package might still need different builds of that package. As a result it could very well happen that your project could not profit a lot from the nixpkgs binary cache even when it had precompiled every version of every Haskell package.</p>
<p>There can probably be said a lot more about this, but I have accepted that the chosen solution in nixpkgs actually has a lot of advantages (mainly fewer compilation work for everyone) and I actually haven‘t encountered a package I couldn‘t get to build with nixpkgs. The truth is the best guess build plan nixpkgs provides us with is normally not very far away from a working build plan. And it actually is a reasonable build plan. As a Haskell developer I think it is a good rule of thumb to always make your project work with the newest versions of all dependencies on hackage. And then it‘s very likely that your package will also work in nixpkgs.</p>
<p>Above I complained that a lot of Haskell packages are broken in nixpkgs. In truth, all commonly used packages work and most other packages are very easy to fix.</p>
<h2 id="building-ghcide-with-nixpkgs">4. Building ghcide with nixpkgs</h2>
<p>So what can we do to fix a broken package on nixpkgs?</p>
<h3 id="how-to-fix-broken-haskell-builds-in-nixpkgs-in-general">How to fix broken Haskell builds in nixpkgs in general</h3>
<p><a href="https://www.youtube.com/watch?v=KLhkAEk8I20">(Also watch this video if you are interested in this).</a></p>
<ol type="1">
<li>Often the error is actually fixed by an upstream version bound change, so you can always just try to compile the package. If it works make a PR against nixpkgs to remove the broken flag.</li>
<li>Often the problem is that the package can actually build with the supplied build plan but cabal doesn‘t believe us. So we can do a “jailbreak” and just tell cabal to ignore the version constraints. We don‘t do this by default because even if the package builds, it might now have changed semantics because of a change in a dependency. So a jailbreaked package should be tested and reported upstream so that the cabal restrictions of that package can get fixed.</li>
<li>If those two don‘t help we can still override the build plan manually to use different versions of the dependencies, not the ones provided by nixpkgs by default.</li>
</ol>
<p>And the third option is what needed to be done for ghcide.</p>
<h3 id="fixing-the-ghcide-build-in-nixpkgs">Fixing the ghcide build in nixpkgs</h3>
<p>There were the following problems <a href="https://github.com/NixOS/nixpkgs/pull/86659">on nixpkgs-20.03</a>:</p>
<ul>
<li><code>hie-bios</code> was broken because of failing tests. Test fails during nix builds are very often false positives, so I disabled the tests.</li>
<li><code>ghcide</code> needed <code>regex-tdfa</code> and <code>haddock-library</code> newer than in the stack-lts. So I just used newer versions of those two libraries. This was not necessary on the <code>haskell-updates</code> branch because it uses a new enough stack lts release.</li>
<li><code>ghcide</code> pins the version of <code>haskell-lsp</code> and <code>haskell-lsp-types</code>. This will probably be the reason why maintaining <code>ghcide</code> in nixpkgs will always be a little bit of manual work because, it would have to be by chance <em>exactly</em> the <code>haskell-lsp</code> version from the stack lts release, to work without manual intervention.</li>
</ul>
<p>So in summary only very few lines of code were needed to get <code>ghcide</code> to work. If you are curious look at <a href="https://github.com/NixOS/nixpkgs/pull/86765">the commit</a>. It</p>
<ul>
<li>enables the generation of <code>haskell-lsp</code> and <code>haskell-lsp-types</code> 0.19.</li>
<li>uses those packages as dependencies for <code>ghcide</code></li>
<li>disables test for <code>hie-bios</code></li>
<li>and marks <code>ghcide</code> and <code>hie-bios</code> as unbroken.</li>
</ul>
<h3 id="fixing-the-ghcide-build-via-overrides">Fixing the ghcide build via overrides</h3>
<p>Sometimes you are stuck with an older nixpkgs version. E.g. I wanted <code>ghcide</code> to work with my obelisk project. Obelisk uses a pinned nixpkgs version <em>and</em> a patched ghc. So what I did was putting the overrides I describe above as overrides into my projects <code>default.nix</code>. That‘s always a nice way to first figure out how to fix a dependency, but of course you help a lot more people if you find a way to upstream the fixes into nixpkgs.</p>
<p>I had to manually create some of the packages with a function called <code>callHackageDirect</code> because the nixpkgs version in reflex-platform was so old. It’s kinda the last way out, but it is very flexible and should be enough to solve most dependency issues. If nothing else helps, create a build plan with cabal and reproduce it by hand with nix overrides. That actually worked for me, when <a href="https://github.com/obsidiansystems/obelisk/issues/660#issuecomment-594277283">I tried to get ghcide to run with obelisk.</a></p>
<h2 id="final-remarks">Final remarks</h2>
<p>Thank you for following me this long. I hope I have illuminated a bit the situation with getting Haskell packages and <code>ghcide</code> specifically to run under nixpkgs. If someday you meet a broken Haskell package in nixpkgs you now hopefully know why, and how to fix it, or at least that fixing it is probably not hard and you should give it a shot.</p>
<p>Installing <code>ghcide</code> for sure isn’t hard anymore. It even works in fairly custom special case development situations like obelisk. So my recommendation is, set it up right now, you won’t want to work without it anymore.</p>
<p>In this post I have touched a lot of topics, which could all use more concrete how-to explanations, and on all of them I am far from an expert. So if you think something is amiss or if you don’t understand something feel free to contact me and maybe we can clarify it.</p>
<p>A big thank you to everyone involved with ghcide, nixpkgs or obelisk who helped me with figuring all of this out! The nice people you meet are what actually makes all of this so much fun.</p>
<p>I personally am definitely looking forward to the first official release of haskell-language-server and I am sure we can land it in nixpkgs quickly. <a href="https://github.com/NixOS/nixpkgs/pull/89447">ghcide 0.2.0 will probably be merged</a> into <a href="https://github.com/NixOS/nixpkgs/pull/89456">nixpkgs master</a> around the same time that this post is getting released.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-29-hiedb</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-29-hiedb.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-29-hiedb.html</id>
    <published>2020-05-29T00:00:00Z</published>
    <updated>2020-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Responsive IDEs </h2>
<p class="text-muted">
    Posted on May 29, 2020 by <a href="https://github.com/wz1000">Zubin Duggal</a>
    <span class="avatar"><img src="/ide/images/wz1000.png"/></span>
</p>

<p>This is the fourth installment in our weekly series of IDE related updates. I will discuss some of the latest developments with respect to the <strong>ghcide</strong> architecture and how we’ve been working to increase its responsiveness.</p>
<!--more-->
<h2 id="slow-response-times-in-ghcide">Slow response times in ghcide</h2>
<p>A while ago, <a href="https://github.com/digital-asset/ghcide/issues/503">Matthew and others noticed</a> that performance for requests like <em>hovering</em> was still far too slow, especially for big projects like ghc. Furthermore, other requests like completions were also pretty useless, since they took ages to show up, and only did so when you paused while typing.</p>
<p>One of the reasons for this turned out to be the way <strong>ghcide</strong> handled new requests. Only one Shake <code>Action</code> can run with access to the Shake database at a time, so when ever new requests came in, <strong>ghcide</strong> would cancel whatever requests were previously running and schedule the new one. This meant that if you started typing, your most recent modification to the file would cancel any already running typecheck from the previous modifications and run a new one. Then, when a completion request came in, it would even cancel this latest typecheck if it was still running, kick off a new typecheck and finally report results when this succeeded. If the typecheck failed, <strong>ghcide</strong> would still try to use the results of the previous typecheck to give you your results, but, <em>crucially</em>, it has to wait for the previous typecheck to fail before it can do this.</p>
<h3 id="a-new-old-solution">A new old solution</h3>
<p>We already had a pretty good idea about how to fix this problem, especially since <strong>haskell-ide-engine</strong> had usable and fast completions. The key idea was to not make arbitrary requests like hover, goto definition and completion cancel running typechecks. Instead, we always want them to use the results of the last successful typecheck. This trades off some correctness for responsiveness, since if a typecheck is running, these requests will not wait for the typecheck to complete before reporting results, and just use the results of the previous typecheck.</p>
<p>In addition to this, we maintain a queue of requests to schedule with shake, and add <code>Action</code>s to this queue to refresh whatever information from the database was accessed by our requests, so that the database is always kept up to date.</p>
<p>This solution was implemented by Matthew, and you can use it by running <a href="https://github.com/mpickering/ghcide/">his branch of <strong>ghcide</strong></a>. This is also the branch of <strong>ghcide</strong> used by <a href="https://github.com/haskell/haskell-language-server"><strong>haskell-language-server</strong></a>.</p>
<h3 id="no-more-waiting-for-your-ide-to-catch-up-to-you">No more waiting for your IDE to catch up to you</h3>
<p>As covered in earlier blog posts, I have been working on integrating <a href="https://github.com/wz1000/hiedb"><strong>hiedb</strong></a> with <strong>ghcide</strong> so that it can display project wide references. While doing this, I was reminded of the <a href="https://clangd.llvm.org/design/indexing.html">architecture</a> of the <a href="https://clangd.llvm.org/">clangd</a> language server, and I realised that many other requests could be served using this model.</p>
<p>The idea is for <strong>ghcide</strong> to act as an indexing service for <strong>hiedb</strong>, generating <code>.hi</code> and <code>.hie</code> files which are indexed and saved in the database, available for all future queries, even across restarts. A local cache of <code>.hie</code> files/typechecked modules is maintained on top of this to answer queries for the files the user is currently editing. All information that is not in some sense “local” to a particular module is accessed through the database. On the other hand, information like the symbol under a point, the references and types of local variables etc. will be accessed through the local cache.</p>
<p>A goal we would like to work towards would be to have an instantly responsive IDE as soon as you open your editor. Ideally, we wouldn’t even want to wait for your code to typecheck before your IDE is usable. Indeed, on my branch of <strong>ghcide</strong>, many features are available instantly, provided a previous run had cached a <code>.hie</code> file for your module on disk.</p>
<script id="asciicast-xkqfc5Fst9yC5gDaPskiNE5au" src="https://asciinema.org/a/xkqfc5Fst9yC5gDaPskiNE5au.js" async></script>
<p>Here you can see that we can use the <code>hover</code> and <code>go to definition</code> features as soon as we open our editor, even on a big project like GHC which takes quite a while to typecheck.</p>
<p>The hover, go to (type) definition, references, document highlight and workspace symbols requests have been (re)written to fit this model. We can even teach <strong>hiedb</strong> to index <code>.hi</code> files, so that module imports, identifiers exported from modules, their types and their documentation are also stored in the database. We can then use this info to serve completion requests.</p>
<p>You can follow along with my progess <a href="https://github.com/wz1000/ghcide/tree/hiedb">here</a>.</p>
<h3 id="space-leaks-and-shake-responsiveness">Space leaks and shake responsiveness</h3>
<p>The un-intuitive behaviour of the GHC and Shake schedulers was responsible for some of the delay while answering requests. It seems like neither’s behaviour is quite optimal for the kinds of workloads <strong>ghcide</strong> generates, which consist of many extremely short running actions.</p>
<p>You can read more about this and Neil’s investigation into it in his <a href="https://neilmitchell.blogspot.com/2020/05/fixing-space-leaks-in-ghcide.html">blog post</a></p>
<h2 id="other-developments">Other developments</h2>
<p>The students accepted for IDE related GSOCs (Luke, Fendor and Michalis) have been gearing up for the official start of their program on the coming Monday.</p>
<ul>
<li>Javier Niera has been looking into the <strong>haskell-language-server</strong> CI and testsuite, as well as porting over the old <strong>haskell-ide-engine</strong> README instructions, so that people can quickly get it set up on their own editors</li>
<li>Fendor has picked up an old <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/1425">GHC MR</a> to reimplement ghci’s <code>:set +c</code> functionality using <code>.hie</code> files</li>
<li>Luke Lau has been working on adding the ability to <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3330">attach haddocks to declarations generated by TH</a> as a yak shave while working on <a href="https://github.com/alanz/haskell-lsp/pull/244">improvements to the <strong>haskell-lsp</strong></a> library</li>
</ul>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-27-ghcide-space-leaks</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-27-ghcide-space-leaks.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-27-ghcide-space-leaks.html</id>
    <published>2020-05-27T00:00:00Z</published>
    <updated>2020-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Fixing Space Leaks in Ghcide </h2>
<p class="text-muted">
    Posted on May 27, 2020 by <a href="https://github.com/ndmitchell">Neil Mitchell</a>
    <span class="avatar"><img src="/ide/images/ndmitchell.png"/></span>
</p>

<h1 id="fixing-space-leaks-in-ghcide">Fixing Space Leaks in Ghcide</h1>
<p>This blog post was first posted on <a href="http://neilmitchell.blogspot.com/2020/05/fixing-space-leaks-in-ghcide.html">Neil’s own blog</a> and is cross-posted here.</p>
<p>Over the bank holiday weekend, I decided to devote some time to a possible <a href="https://shakebuild.com/">Shake build system</a> performance issue in <a href="https://github.com/digital-asset/ghcide">Ghcide Haskell IDE</a>. As I started investigating (and mostly failed) I discovered a space leak which I eventually figured out, solved, and then (as a happy little accident) got a performance improvement anyway. This post is a tale of what I saw, how I tackled the problem, and how I went forward. As I’m writing the post, not all the threads have concluded. I wrote lots of code during the weekend, but most was only to experiment and has been thrown away - I’ve mostly left the code to the links. Hopefully the chaotic nature of development shines through.</p>
<h2 id="shake-thread-pool-performance">Shake thread-pool performance</h2>
<p>I started with <a href="https://github.com/ndmitchell/shake/pull/751">a Shake PR</a> claiming that simplifying the Shake thread pool could result in a performance improvement. Faster and simpler seems like a dream combination. Taking a closer look, simpler seemed like it was simpler because it supported less features (e.g. ability to kill all threads when one has an exception, some fairness/scheduling properties). But some of those features (e.g. better scheduling) were in the pursuit of speed, so if a simpler scheduler was 30% faster (the cost of losing randomised scheduling), that might not matter.</p>
<p>The first step was to <a href="https://github.com/ndmitchell/shake/pull/751#issuecomment-632634439">write a benchmark</a>. It’s very hard to synthesise a benchmark that measures the right thing, but spawning 200K short tasks into the thread pool seemed a plausible start. As promised on the PR, the simpler version did indeed run faster. But interestingly, the simplifications weren’t really responsible for the speed difference - switching from <code>forkIO</code> to <code>forkOn</code> explained nearly all the difference. I’m not that familiar with <code>forkOn</code>, so decided to micro-benchmark it - how long does it take to spawn off 1M threads with the two methods. I found two surprising results:</p>
<ul>
<li>The performance of <code>forkOn</code> was quadratic! A <a href="https://gitlab.haskell.org/ghc/ghc/issues/18221">GHC bug</a> explains why - it doesn’t look too hard to fix, but relying on <code>forkOn</code> is unusual, so its unclear if the fix is worth it.</li>
<li>The performance of <code>forkIO</code> was highly inconsistent. Often it took in the region of 1 second. Sometimes it was massively faster, around 0.1s. A <a href="https://stackoverflow.com/questions/61971292/ghc-forkio-bimodal-performance">StackOverflow question</a> didn’t shed much light on <em>why</em>, but did show that by using the <a href="https://hackage.haskell.org/package/pvar/docs/Data-Primitive-PVar.html#t:PVar"><code>PVar concurrency primitive</code></a> it could be 10x faster. There is a <a href="https://gitlab.haskell.org/ghc/ghc/issues/18224">GHC bug tracking the issue</a>, and it seems as though the thread gets created them immediately switches away. There is a suggestion from Simon Peyton Jones of a heuristic that might help, but the issue remains unsolved.</li>
</ul>
<p>My desire to switch the Shake thread-pool to a quadratic primitive which is explicitly discouraged is low. Trying to microbenchmark with primitives that have inconsistent performance is no fun. The hint towards <code>PVar</code> is super interesting, and I may follow up on it in future, but given the remarks in the GHC tickets I wonder if <code>PVar</code> is merely avoiding one small allocation, and avoiding an allocation avoids a context switch, so it’s not a real signal.</p>
<p>At this point I decided to zoom out and try benchmarking all of Ghcide.</p>
<h2 id="benchmarking-ghcide">Benchmarking Ghcide</h2>
<p>The thread about the Shake thread pool pointed at <a href="https://github.com/digital-asset/ghcide/issues/503">a benchmarking approach</a> of making hover requests. I concluded that making a hover request with no file changes would benchmark the part of Shake I thought the improved thread-pool was most likely to benefit. I used the Shake source code as a test bed, and opened a file with 100 transitive imports, then did a hover over the <code>listToMaybe</code> function. I know that will require Shake validating that everything is up to date, and then doing a little bit of hover computation.</p>
<p>I knew I was going to be running Ghcide a lot, and the Cabal/Stack <code>build</code> steps are frustratingly slow. In particular, every time around Stack wanted to unregister the Ghcide package. Therefore, I wrote a simple <code>.bat</code> file that <a href="https://gist.github.com/ndmitchell/11467985dbf1855e62035fa97248a585#file-test-bat">compiled Ghcide and my benchmark</a> using <code>ghc --make</code>. So I could experiment quickly with changes to Shake, I pulled in all of Shake as source, not as a separate library, with an include path. I have run that benchmark 100’s of times, so the fact it is both simple (no arguments) and as fast as I could get has easily paid off.</p>
<p>For the benchmark itself, I first went down the route of looking at the <a href="https://hackage.haskell.org/package/lsp-test/docs/Language-Haskell-LSP-Test-Replay.html#v:replaySession">replay functionality</a> in <a href="https://hackage.haskell.org/package/lsp-test">lsp-test</a>. Sadly, that code doesn’t link to anything that explains how to <em>generate</em> traces. After asking on the <a href="https://webchat.freenode.net/?channels=haskell-ide-engine">haskell-ide-engine IRC</a> I got pointed at both the existing functionality of <a href="https://hackage.haskell.org/package/haskell-lsp-0.22.0.0/docs/Language-Haskell-LSP-Core.html#v:resCaptureFile"><code>resCaptureFile</code></a>. I also got pointed at the <a href="https://github.com/alanz/haskell-lsp/pull/247/files">vastly improved version in a PR</a>, which doesn’t fail if two messages race with each other. Configuring that and running it on my benchmark in the IDE told me that the number of messages involved was tiny - pretty much an initialisation and then a bunch of hovers. Coding those directly in <code>lsp-test</code> was trivial, and so <a href="https://gist.github.com/ndmitchell/11467985dbf1855e62035fa97248a585#file-benchmark-hs">I wrote a benchmark</a>. The essence was:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">doc <span class="ot">&lt;-</span> openDoc <span class="st">&quot;src/Test.hs&quot;</span> <span class="st">&quot;haskell&quot;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">(t, _) <span class="ot">&lt;-</span> duration <span class="fu">$</span> replicateM_ <span class="dv">100</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    getHover doc <span class="fu">$</span> <span class="dt">Position</span> <span class="dv">127</span> <span class="dv">43</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">print t</a></code></pre></div>
<p>Open a document. Send 100 hover requests. Print the time taken.</p>
<h2 id="profiling-ghcide">Profiling Ghcide</h2>
<p>Now I could run 100 hovers, I wanted to use the GHC profiling mechanisms. Importantly, the 100 hover requests dominates the loading by a huge margin, so profiles would focus on the right thing. I ran a profile, but it was empty. Turns out the way <code>lsp-test</code> invokes the binary it is testing means it kills it too aggressively to allow GHC to write out profiling information. I changed the benchmark to send a shutdown request at the end, then sleep, and changed Ghcide to abort on a shutdown, so it could write the profiling information.</p>
<p>Once I had the profiling information, I was thoroughly uniformed. 10% went in file modification checking, which <a href="https://github.com/digital-asset/ghcide/issues/583">could be eliminated</a>. 10% seemed to go to hash table manipulations, which seemed on the high side, but not too significant (turned out I was totally wrong, read to the end!). Maybe 40% went in the Shake monad, but profiling exaggerates those costs significantly, so it’s unclear what the truth is. Nothing else stood out, but earlier testing when profiling <code>forkIO</code> operations had shown they weren’t counted well, so that didn’t mean much.</p>
<h2 id="prodding-ghcide">Prodding Ghcide</h2>
<p>In the absence of profiling data, I started changing things and measuring the performance. I tried a bunch of things that made no difference, but some things did have an impact on the time to do 100 hovers:</p>
<ul>
<li>Running normally: 9.77s. The baseline.</li>
<li>Switching to <code>forkOn</code>: 10.65s. Suggestive that either Ghcide has changed, or the project is different, or platform differences mean that <code>forkOn</code> isn’t as advantageous.</li>
<li>Using only one Shake thread: 13.65s. This change had been suggested in one ticket, but made my benchmark worse.</li>
<li>Avoid spawning threads for things I think will be cheap: 7.49s. A useful trick, and maybe one that will be of benefit in future, but for such a significant change a 25% performance reduction seemed poor.</li>
<li>Avoid doing any Shake invalidation: 0.31s. An absolute lower bound if Shake cheats and does nothing.</li>
</ul>
<p>With all that, I was a bit dejected - performance investigation reveals nothing of note was not a great conclusion from a days work. I think that other changes to Ghcide to <a href="https://github.com/digital-asset/ghcide/pull/554">run Shake less</a> and <a href="https://github.com/wz1000/ghcide/tree/hiedb">cache data more</a> will probably make this benchmark even less important, so the conclusion worsens - performance investigation of nothing of note reveals nothing of note. How sad.</p>
<p>But in my benchmark I did notice something - a steadily increasing memory size in process explorer. Such issues are pretty serious in an interactive program, and <a href="https://github.com/digital-asset/ghcide/pull/557">we’d fixed several issues recently</a>, but clearly there were more. Time to change gears.</p>
<h2 id="space-leak-detection">Space leak detection</h2>
<p>Using the benchmark I observed a space leak. But the program is huge, and manual code inspection usually needs a 10 line code fragment to have a change. So I started modifying the program to do less, and continued until the program did as little as it could, but still leaked space. After I fixed a space leak, I zoomed out and saw if the space leak persisted, and then had another go.</p>
<p>The first investigation took me into the Shake Database module. I found that if I ran the Shake script to make everything up to date, but did no actions inside, then there was a space leak. Gradually commenting out lines (over the course of several hours) eventually took me to:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">step <span class="ot">&lt;-</span> pure <span class="fu">$</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="dt">Just</span> (_, <span class="dt">Loaded</span> r) <span class="ot">-&gt;</span> incStep <span class="fu">$</span> fromStepResult r</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    _ <span class="ot">-&gt;</span> <span class="dt">Step</span> <span class="dv">1</span></a></code></pre></div>
<p>This code increments a step counter on each run. In normal Shake this counter is written to disk each time, which forces the value. In Ghcide we use Shake in memory, and nothing ever forced the counter. The change was simple - replace <code>pure</code> with <code>evaluate</code>. This fix has been <a href="https://github.com/ndmitchell/shake/commit/8da74bab4a2466b52f8ddc50b75a56139eecb273">applied to Shake HEAD</a>.</p>
<h2 id="space-leak-detection-2">Space leak detection 2</h2>
<p>The next space leak took me to the Shake database <code>reset</code> function, which moves all Shake keys from <code>Ready</code> to <code>Loaded</code> when a new run starts. I determined that if you didn’t run this function, the leak went away. I found a few places I should have <a href="https://github.com/ndmitchell/shake/commit/04b0fb349a5e8ff84c073f9751bcef11b3928570">put strictness annotations</a>, and a function that <a href="https://github.com/ndmitchell/shake/commit/ddf5e2d2020decc44f08c2d5482b8941c5c6d816">mutated an array lazily</a>. I reran the code, but the problem persisted. I eventually realised that if you don’t call <code>reset</code> then none of the user rules run either, which was really what was fixing the problem - but I committed the improvements I’d made even though they don’t fix any space leaks.</p>
<p>By this point I was moderately convinced that Shake wasn’t to blame, so turned my attention to the user rules in Ghcide. I stubbed them out, and the leak went away, so that looked plausible. There were 8 types of rules that did meaningful work during the hover operation (things like <code>GetModificationTime</code>, <code>DoesFileExist</code>, <code>FilesOfInterest</code>). I picked a few in turn, and found they all leaked memory, so picked the simple <code>DoesFileExist</code> and looked at what it did.</p>
<p>For running <code>DoesFileExist</code> I wrote a very quick “bailout” version of the rule, equivalent to the “doing nothing” case, then progressively enabled more bits of the rule before bailing out, to see what caused the leak. The bailout looked like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">Just</span> v <span class="ot">&lt;-</span> getValues state key file</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">let</span> bailout <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">RunResult</span> <span class="dt">ChangedNothing</span> old <span class="fu">$</span> <span class="dt">A</span> v</a></code></pre></div>
<p>I progressively enabled more and more of the rule, but even with the whole rule enabled, the leak didn’t recur. At that point, I realised I’d introduced a syntax error and that all my measurements for the last hour had been using a stale binary. Oops. I span up a copy of <a href="https://github.com/ndmitchell/ghcid">Ghcid</a>, so I could see syntax errors more easily, and repeated the measurements. Again, the leak didn’t recur. Very frustrating.</p>
<p>At that point I had two pieces of code, one which leaked and one which didn’t, and the <em>only</em> difference was the unused <code>bailout</code> value I’d been keeping at the top to make it easier to quickly give up half-way through the function. Strange though it seemed, the inescapable conclusion was that <code>getValues</code> must somehow be fixing the space leak.</p>
<p>If <code>getValues</code> fixes a leak, it is a likely guess that <code>setValues</code> is causing the leak. I modified <code>setValues</code> to also call <code>getValues</code> and the problem went away. But, after hours of staring, I couldn’t figure out why. The code of <code>setValues</code> read:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">setValues state key file val <span class="fu">=</span> modifyVar_ state <span class="fu">$</span> \vals <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    evaluate <span class="fu">$</span> HMap.insert (file, <span class="dt">Key</span> key) (fmap toDyn val) vals</a></code></pre></div>
<p>Namely, modify a strict <code>HashMap</code> from <a href="https://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a>, forcing the result. After much trial and error I determined that a “fix” was to add:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">case</span> HMap.lookup k res <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure ()</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="dt">Just</span> v <span class="ot">-&gt;</span> void <span class="fu">$</span> evaluate v</a></code></pre></div>
<p>It’s necessary to insert into the strict <code>HashMap</code>, then do a <code>lookup</code>, then evaluate the result that comes back, or there is a space leak. I duly <a href="https://github.com/digital-asset/ghcide/pull/586">raised a PR to Ghcide</a> with the unsatisfying comment:</p>
<blockquote>
<p>I’m completely lost, but I do have a fix.</p>
</blockquote>
<p>It’s nice to fix bugs. It’s better to have some clue why a fix works.</p>
<h2 id="space-leak-in-hashmap">Space leak in <code>HashMap</code></h2>
<p>My only conclusion was that <code>HashMap</code> must have a space leak. I took a brief look at the code, but it was 20+ lines and nothing stood out. I wrote a benchmark that inserted billions of values at 1000 random keys, but it didn’t leak space. I puzzled it over in my brain, and then about a day later inspiration struck. One of the cases was to deal with collisions in the <code>HashMap</code>. Most <code>HashMap</code>’s don’t have any collisions, so a bug hiding there could survive a very long time. I wrote a benchmark with colliding keys, and lo and behold, it leaked space. Concretely, it leaked 1Gb/s, and brought my machine to its knees. The benchmark inserted three keys all with the same hash, then modified one key repeatedly. I posted the <a href="https://github.com/tibbe/unordered-containers/issues/254">bug to the <code>unordered-containers</code> library</a>.</p>
<p>I also looked at the code, figured out why the space leak was occurring, and a potential fix. However, the fix requires duplicating some code, and its likely the same bug exists in several other code paths too. The <code>Lazy</code> vs <code>Strict</code> approach of <code>HashMap</code> being dealt with as an outer layer doesn’t quite work for the functions in question. I took a look at the PR queue for <code>unordered-containers</code> and saw 29 requests, with the recent few having no comments on them. That’s a bad sign and suggested that spending time preparing a PR might be in vain, so I didn’t.</p>
<p>Aside: Maintainers get busy. It’s no reflection negatively on the people who have invested lots of time on this library, and I thank them for their effort! Given <a href="https://packdeps.haskellers.com/reverse/unordered-containers">1,489 packages on Hackage</a> depend on it, I think it could benefit from additional bandwidth from someone.</p>
<h2 id="hash-collisions-in-ghcide">Hash collisions in Ghcide</h2>
<p>While hash collisions leading to space leaks is bad, having hash collisions at all is also bad. I augmented the code in Ghcide to print out hash collisions, and saw collisions between <code>(&quot;Path.hs&quot;, Key GetModificationTime)</code> and <code>(&quot;Path.hs&quot;, Key DoesFileExist)</code>. Prodding a bit further I saw that the <code>Hashable</code> instance for <code>Key</code> only consulted its argument value, and given most key types are simple <code>data Foo = Foo</code> constructions, they all had the same hash. The solution was to mix in the type information stored by <code>Key</code>. I changed to the definition:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">hashWithSalt salt (<span class="dt">Key</span> key) <span class="fu">=</span> hashWithSalt salt (typeOf key) <span class="ot">`xor`</span> hashWithSalt salt key</a></code></pre></div>
<p>Unfortunately, that now gave hash collisions with different paths at the same key. I looked into the hashing for the path part (which is really an <code>lsp-haskell-types</code> <code>NormalizedFilePath</code>) and saw that it used an optimised hashing scheme, precomputing the hash, and returning it with <code>hash</code>. I also looked at the <code>hashable</code> library and realised the authors of <code>lsp-haskell-types</code> hadn’t implemented <code>hashWithSalt</code>. If you don’t do that, a generic instance is constructed which deeply walks the data structure, completely defeating the <code>hash</code> optimisation. A <a href="https://github.com/alanz/haskell-lsp/pull/248">quick PR fixes that</a>.</p>
<p>I also found that for tuples, the types are combined by using the <code>salt</code> argument. Therefore, to hash the pair of path information and <code>Key</code>, the <code>Key</code> <code>hashWithSalt</code> gets called with the <code>hash</code> of the path as its salt. However, looking at the definition above, you can imagine that both <code>hashWithSalt</code> of a type and <code>hashWithSalt</code> of a key expand to something like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">hashWithSalt salt (<span class="dt">Key</span> key) <span class="fu">=</span> salt <span class="ot">`xor`</span> hash (typeOf key) <span class="ot">`xor`</span> (salt <span class="ot">`xor`</span> <span class="dv">0</span>)</a></code></pre></div>
<p>Since <code>xor</code> is associative and commutative, those two <code>salt</code> values cancel out! While I wasn’t seeing complete cancellation, I was seeing quite a degree of collision, so I changed to:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">hashWithSalt salt (<span class="dt">Key</span> key) <span class="fu">=</span> hashWithSalt salt (typeOf key, key)</a></code></pre></div>
<p>With that <a href="https://github.com/digital-asset/ghcide/pull/588">fix in Ghcide</a>, all collisions went away, and all space leaks left with them. I had taken this implementation of hash combining from Shake, and while it’s not likely to be a problem in the setting its used there, <a href="https://github.com/ndmitchell/shake/commit/297c60fa0c6b0d4e98f61b9cdb1359a409cda901">I’ve fixed it in Shake too</a>.</p>
<h2 id="benchmarking-ghcide-1">Benchmarking Ghcide</h2>
<p>With the hash collisions reduced, and the number of traversals when computing a hash reduced, I wondered what the impact was on performance. A rerun of the original benchmark showed the time had reduced to 9.10s - giving a speed up of about 5%. Not huge, but welcome.</p>
<p>Several days later we’re left with less space leaks, more performance, and hopefully a better IDE experience for Haskell programmers. I failed in what I set out to do, but found some other bugs along the way, leading to 9 PRs/commits and 4 ongoing issues. I’d like to thank everyone in the Haskell IDE team for following along, making suggestions, confirming suspicions, and generally working as a great team. <a href="https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html">Merging the Haskell IDE efforts</a> continues to go well, both in terms of code output, and team friendliness.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-22-tracing-plan</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-22-tracing-plan.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-22-tracing-plan.html</id>
    <published>2020-05-22T00:00:00Z</published>
    <updated>2020-05-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Adding tracing to ghcide </h2>
<p class="text-muted">
    Posted on May 22, 2020 by <a href="https://github.com/mpardalos">Michalis Pardalos</a>
    <span class="avatar"><img src="/ide/images/mpardalos.png"/></span>
</p>

<p>Welcome to the third post on the ongoing work on a unified Haskell IDE. This week I will be talking about my Google Summer of Code project to <em>introduce tracing into ghcide</em> using OpenTelemetry. I will explain the motivation for this project and then explain what it actually entails, as well as what improvements you should expect to see as a result of it.</p>
<figure>
<img src="/ide/images/trace-example.png" alt="A ghcide trace viewed in chrome’s about:tracing" style="width:100.0%" /><figcaption>A ghcide trace viewed in chrome’s about:tracing</figcaption>
</figure>
<!--more-->
<h3 id="what-is-the-problem">What is the problem?</h3>
<p>The internal architecture of ghcide is based on the <a href="https://shakebuild.com">Shake</a> build system. This is a tool similar in principle to UNIX make, except implemented as a Haskell library. While using a build tool as the core of an IDE might be surprising, it simplifies the internals of the engine, and allows for reuse of information. This is a big contributor to ghcide’s speed. A more detailed explanation is given <a href="https://4ta.uk/p/shaking-up-the-ide">here</a>.</p>
<p>It’s not all rosy though. In order for shake to provide these benefits, it must entirely (with some caveats) control the execution of the IDE engine. Shake loads/parses/typechecks files whenever it sees fit, based on which files have changed and what is requested by the editor. This means that reasoning about performance becomes much harder. It’s hard to tell what action is slow when you don’t know or directly control which ones are running.</p>
<h3 id="so-what-are-you-doing-about-it">So what are you doing about it?</h3>
<p>Addressing this problem is the core of my Google Summer of Code project: I will be introducing tracing to ghcide. This essentially amounts to wrapping interesting sections of code in <code>print &quot;begin &lt;section&gt;&quot;</code> and <code>print &quot;end &lt;section&gt;&quot;</code>, albeit in a slightly more sophisticated way. This will allow us to track which sections are running at any given time and for how long. I will be doing this using <a href="https://opentelemetry.io/">opentelemetry</a> and Dmitry Ivanov’s (@ethercrow) <code>haskell-opentelemetry</code> library, allowing for better tooling support over simple console logging.</p>
<p>OpenTelemetry is a set of tools and APIs for monitoring applications in a variety of ways. We will be using its tracing portion which will allow us to view traces from ghcide in any opentelemetry-compatible viewer, like <a href="https://jaegertracing.io/">Jaeger</a> or Google Chrome’s <code>about:tracing</code>. So, to address some confusion from the reddit comments on last week’s post: This has nothing to do with telemetry, as used in e.g. Visual Studio Code or Windows. It is explicitly opt-in and does not transmit any data over the network.</p>
<p>Matthew Pickering (@mpickering) has already started this effort. He has added initial support for tracing allowing us to get some basic traces. You can see an example of what is possible below:</p>
<p align="center">
<img src="/ide/images/trace-example.png" alt="A ghcide trace viewed in chrome’s about:tracing" style="width:100.0%" />
</p>
<p>This is a trace of ghcide running on GHC. Each bar represents a Shake Action, which is described by the text on the bar. For example the first bar represents loading the first file when the editor was started. You can see that we get no detail beyond how long the entire action took. We can’t tell if certain dependent modules took more or less time, or if the loading was properly parallelised.</p>
<p>The way shake works is that you issue <em>Actions</em> to be run, which can then request data, which based on <em>rules</em> is computed using other Actions, etc. We can currently only trace the initial actions, not any of their dependencies. For example, we know can see how long going to definition takes in its entirety, but not how much of that time was spent loading or parsing files. Adding this will give us a complete picture of what ghcide is doing, and is what I will be adding to ghcide’s tracing.</p>
<h2 id="thats-great-and-all-but-what-do-i-get">That’s great and all, but what do I get?</h2>
<p>Great question! Indeed, this is a developer-facing feature. We are not expecting users of ghcide to be looking at traces. We are hoping however it will guide us towards a faster ghcide by showing us what parts are worth improving. It should also make locating certain classes of bugs easier by showing us if Shake is doing what we are expecting it to.</p>
<h3 id="other-updates">Other Updates</h3>
<p>As always, we have all been working on other projects as well this week.</p>
<ul>
<li>Luke Lau has been <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3330">implementing support</a> for adding haddock documentation to functions using template-haskell to resolve a long standing GHC ticket.</li>
<li>Fendor submitted his first <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3327">GHC patch</a> getting up to speed for the summer’s project.</li>
<li>Matthew Pickering has been finishing off the <a href="https://github.com/digital-asset/ghcide/pull/522">multi component patch</a> with the careful review of Moritz and Pepe. It looks like it will be merged within the next week.</li>
<li>Avi Dessauer released the first version of <a href="https://hackage.haskell.org/package/implicit-hie">implicit-hie</a> which attempts to generate hie.yaml files for you.</li>
<li>Zubin Duggal has continued working on integrating hie files into his fork of ghcide. You can read more about this in Zubin’s blog post next week.</li>
</ul>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-15-multiple-components</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-15-multiple-components.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-15-multiple-components.html</id>
    <published>2020-05-15T00:00:00Z</published>
    <updated>2020-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Weekly Update and Multiple Components </h2>
<p class="text-muted">
    Posted on May 15, 2020 by <a href="https://github.com/fendor">Fendor</a>
    <span class="avatar"><img src="/ide/images/fendor.png"/></span>
</p>

<p>This is the second blog post in this year’s series of IDE blog posts. In this blog post I will first present the progress we made during the last week, what we have been working on, what has been implemented, and what has been fixed. In the second section I will give some insights on why Haskell IDE Engine is in the retirement process. It explains the shortcomings of its structure and why ghcide supersedes it. In the last section, I will explain the motivation for implementing multiple home packages for GHC and how it, hopefully, will benefit IDEs and every-day users of GHC.</p>
<p><a href="https://gifyu.com/image/nkjS"><img src="https://s6.gifyu.com/images/JumpToInstance.gif" alt="Jump To Instance Definition" /></a></p>
<!--more-->
<h2 id="this-week">This week</h2>
<p>A week has passed since the introduction to the state of IDEs in Haskell. A lot has happened in this one week and I am here to tell you about a few things in detail!</p>
<h3 id="support-for-ghc-8.10.1">Support for GHC 8.10.1</h3>
<p>Maintaining an IDE is a lot of work and we couldn’t do it without the work of volunteers. Part of the maintenance work is updating dependencies and fixing any errors that might occur! This week, as during countless weeks before that, Javier Neira (@jneira) took care of a lot of maintenance work such as responding to issues, fixing bugs and updating Haskell Language Server to be compatible with GHC 8.10.1! Updating Haskell Language Server to support a new GHC version is a huge effort, as it has plenty of dependencies and all of these need to be updated in order to support the newer version.</p>
<h3 id="references">References</h3>
<p><strong>Disclaimer</strong> This feature hasn’t been merged, yet, due to issues with older GHC versions.</p>
<p>Modern IDEs need to be capable of showing you all references to a function, where it is implemented and intelligent code search in general. It should not be necessary to query the function name throughout the whole project to find the implementation. While code-actions such as “Go to Definition” and “Go to Type Definition” have been working for some time now, searching for all references of an identifier has not been implemented as of yet.</p>
<p>But this is bound to change soon! Zubin Duggal developed a working implementation of finding references in a project based on <a href="https://github.com/wz1000/hiedb">hiedb</a>. <code>hiedb</code> is powered by <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/hie-files">HIE</a> files, which are basically very verbose compiler artefacts that can be used to query references, the type of an expression, and a lot of other things (see projects such as <a href="https://hackage.haskell.org/package/weeder">weeder</a>).</p>
<p>Below is a working example of how these HIE files can be used:</p>
<p><a href="https://gifyu.com/image/nkzg"><img src="https://s6.gifyu.com/images/References.gif" alt="Find References" style="width:100.0%" /></a></p>
<p>It allows developers to look for all usages of a function or type and to see all usages of a parameter or definition within a function!</p>
<h3 id="jump-to-instance-definition">Jump to Instance Definition</h3>
<p><strong>Disclaimer</strong> This feature is not yet merged into GHC, but will probably ship with GHC 8.12.</p>
<p>It is well known that you can jump to function definitions in Haddock. For functions that are part of a type-class, you jump to the type-class declaration. However, that is usually not what you want. Thus, Zubin Duggal has implemented a new feature that will allow you to jump to the specific instance definition used by an overloaded function.</p>
<p><a href="https://gifyu.com/image/nkjS"><img src="https://s6.gifyu.com/images/JumpToInstance.gif" alt="Jump To Instance Definition" /></a></p>
<p>This is a really useful feature and will make it easier to explore a code base! Moreover, it can make the IDE experience smoother for developers. LSP supports returning multiple locations for go-to definition requests which we could exploit to give the user a choice about where to jump to.</p>
<h3 id="first-step-towards-open-telemetry-support">First step towards <code>Open Telemetry</code> support</h3>
<p>We are happy to announce that the first <a href="https://github.com/mpickering/ghcide/pull/26">Pull Request</a> of Michalis (@mpardalos) has been merged to Haskell Language Server!</p>
<p>It is a small step compared to the big task ahead to provide telemetry data of IDEs such as the Haskell Language Server. The final goal is to gain insight into the performance of big projects and optimising bottlenecks. To accomplish this, <a href="https://opentelemetry.io/">Open Telemetry</a> will be used to emit relevant performance information. Very recently, the <a href="https://hackage.haskell.org/package/opentelemetry">opentelemetry</a> package was added to Hackage by Dmitry Ivanov (@ethercrow) which will aid the task.</p>
<h3 id="memorable-bug-fixes">Memorable Bug-Fixes</h3>
<p>I will now highlight some of the most memorable bugs we fixed this week, when working on the Haskell Language Server.</p>
<h4 id="completions">Completions</h4>
<p>Since the last blog post, we were informed that there were no completions being provided by the Haskell Language Server, although there are completions when using ghcide. What happened here? Why did Haskell Language Server not use the completion system of ghcide?</p>
<p>The answer was, the completion plugin had not been enabled. Thank you @korayal for providing the <a href="https://github.com/haskell/haskell-language-server/pull/107">fix</a> to this issue!</p>
<p>As an interesting side-note, the completion system of ghcide is almost the same as the one from Haskell IDE Engine! It was ported to ghcide (with some tweaks) and now found its way back into Haskell Language Server.</p>
<h4 id="bad-interface-files">Bad Interface Files</h4>
<p>A particularly nasty bug occured when cached interface files were out of sync. The details of how a project is loaded are described later, but for now it suffices to know that packages are loaded only if one of its modules is loaded. If multiple packages are loaded into the same Language Server session, the cached interface files reflect that fact. This does not cause any problem in the same session, but if it is restarted and a single package loaded, the cache files still try to refer to the package that is not currently loaded. This leads to the whole session not being able to be loaded correctly and then displaying a sea of red squiggly lines until the previous session state is restored, e.g. other packages are loaded into the IDE.</p>
<p>This is obviously not the desired behaviour and, luckily, the fix was rather simple: We needed to isolate the cached interface files based on the packages that were currently loaded! This means that we maintain a set of cached interface files for every subset of loaded local packages. To illustrate this, imagine you have three packages A, B and C. The package A depends on B and C. When we load only the package A, we cache interface files so that subsequent loads of the package are faster. When we additionally load the package B, we cache interface files for B and new interface files for A. If we now load C, we have to re-cache the interface files again for A and B and generate new ones for C. In total, we now have three different sets of cache files for A, two for B and one for C. Overall, six sets of cached interface files have been created. When restarting the session and only opening the package A we will now use interface files for A for which no other package has been loaded. This is arguably a bit inefficient, but we expect to be able to reduce the number of cached interface files in the future.</p>
<p>We fixed the described bug at the cost of using more storage for cached interface files.</p>
<h2 id="the-sunset-of-haskell-ide-engine">The sunset of Haskell IDE Engine</h2>
<p>In this section I am going to briefly explain some of the terminology which is often used in the IDE context.</p>
<ul>
<li>Component: A component is a set of modules that form a single unit of code. For example, the library of a project is a component, the test-suite is a component and the executable is one as well.</li>
<li>Package: A package may consist of multiple components. It usually can be described using a single <code>.cabal</code> file.</li>
<li>Packages in GHC: packages in GHC resemble components, seeing as they are a set of modules that can be compiled with given options.</li>
</ul>
<p>As you may know, you can open a single component with <code>cabal</code> in a ghci session, via <code>cabal repl</code>. However, when you load an executable component which depends on the library component and make any changes to this component, you have to restart the whole session in order for your changes to take effect. This is rather inconvenient for local development but it turns out that Haskell IDE Engine works rather similarly. It loads a single component, which it can update just fine, but if you try to load a second one, a separate session (in a so-called <code>HscEnv</code>) is created which is separated from the first component. Thus, you may modify each component individually, but updates from one component will not be reflected on the other one until the whole Server is restarted. This is a major flaw in Haskell IDE Engine, one that is almost impossible to fix with the current structure. It would require to copy substantial parts of GHC into Haskell IDE Engine, and heavily modify them in order to implement this somewhat basic feature of updating the executable when the library is changed. In the end, this flaw sealed the fate of Haskell IDE Engine. Out of the ashes, ghcide rose, integrating some parts of GHC, such as parsing and typechecking a module and gaining better control and performance.</p>
<p>However, at the time of this writing, mainline ghcide does not support loading multiple components at the same time. So, was everything for nothing and Haskell IDEs will never get their happy ending? Not at all! It is merely not merged yet! Haskell Language Server provides support for loading multiple components at once by using a fork of <a href="https://github.com/mpickering/ghcide">ghcide</a> created by Matthew Pickering (@mpickering). Therefore, we can continue on our quest, implementing feature after feature until Haskell Language Server is a full-blown, highly-performant, reliable IDE? Unfortunately, there is still a catch to this story.</p>
<h2 id="reliable-multi-component-support">Reliable Multi Component Support</h2>
<p>The current implementation of multiple component support is somewhat… hacky. In the previous section, we described how Haskell IDE Engine supports loading multiple components and how this is lacking for a modern IDE. In Haskell Language Server, we are essentially tricking the compiler into thinking that all these components, libraries, executables and so on, are part of the same GHC package, each with a different set of compilation options. While this works fairly well in practice, it is complex and error-prone code. It is also a lot of work to maintain in the Language Server, e.g. supporting multiple GHC versions, keeping it performant, not introducing nasty bugs with new changes and adding new features, such as supporting <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/backpack">backpack</a>.</p>
<p>This is where my Google Summer Of Code project comes into play: this multiple component support ought to be taken care of by GHC itself! The Language Server should not be responsible of maintaining this chunk of code. Technically, the aim is to support multiple home packages in GHC and my work will be based on <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/935">existing efforts</a> of John Ericson (@Ericson2314) who is going to mentor me in this project, alongside Matthew Pickering and Zubin Duggal. If this project succeeds, not only will it be easier for IDEs to support multiple components in general, there is also direct benefit for the whole community! The issue that you can only load a single component into the same <code>ghci</code> session without resorting to complex tricks will be solved by this too. Not only will this improve usability of <code>ghci</code> for every user, different tools such as <code>ghcid</code> could be updated as well.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-08-state-of-haskell-ide</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-08-state-of-haskell-ide.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-08-state-of-haskell-ide.html</id>
    <published>2020-05-08T00:00:00Z</published>
    <updated>2020-05-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> The State of Haskell IDEs </h2>
<p class="text-muted">
    Posted on May  8, 2020 by <a href="https://github.com/bubba">Luke Lau</a>
    <span class="avatar"><img src="/ide/images/bubba.png"/></span>
</p>

<p>It is an exciting time for Haskell tooling. As many might be aware, the past year has seen a number of significant changes to the ecosystem, with one of the most noticeable ones being <a href="https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html">the marriage of ghcide and haskell-ide-engine</a>. We now have contributors from both projects working towards a unified vision of a language server, the <em>haskell-language-server</em>, which aims to be the de-facto IDE for veteran and newcomer Haskellers alike: A full-fledged LSP server that provides diagnostics, code completion, navigation and more, works with both your Cabal and Stack projects, and scales from tiny scripts all the way up to huge codebases like GHC.</p>
<p><em>haskell-language-server</em> does not do this on its own however. It builds upon a whole ecosystem of tools to drive all of the underlying IDE features. How they all interconnect can be a bit overwhelming at first, so this post will break it down and take a look at them individually.</p>
<p align="center">
<img src="/ide/images/tooling-graph.png" alt="An overview of the current ecosystem" width="400" />
</p>
<!--more-->
<h3 id="ghcide">ghcide</h3>
<p>Powering the language server under the hood is <a href="https://github.com/digital-asset/ghcide">ghcide</a>. Based on tooling built for DAML, it is the core piece of infrastructure that talks to GHC to parse and typecheck your code. One of its many clever innovations is the use of the Shake build system to keep an in-memory cache of modules, file contents and other computations (e.g. code completions). Tooling built on top of it can then query it to get responsive, up-to-date information about the code it is working with. ghcide is also a language server itself, so if you need a lightweight IDE without any fancy trimmings then it will slot right in with any LSP client.</p>
<h3 id="hie-bios">hie-bios</h3>
<p>In order for ghcide to set up the GHC session, it needs to know what set of flags to pass to it. Unfortunately, this is not just as simple as <code>-Wall -O1</code> — if you ever run <code>cabal build -v</code> you will find that there are loads of flags passed to GHC, a lot of them related to whatever packages your project depends on. <a href="https://github.com/mpickering/hie-bios">hie-bios</a> takes care of this by querying the underlying build tool, such as Stack, Cabal or Hadrian, delegating it the work of figuring out the flags and building any package dependencies that might be needed. By specifying a <code>hie.yaml</code> file in your project’s root directory, you can specify one or more <em>cradles</em>, where each cradle represents some component to build with a specific build tool.</p>
<h3 id="cabal-helper">cabal-helper</h3>
<p>You can leave out the <code>hie.yaml</code> file, and hie-bios will try its best to infer which components to build with which tools. However this can get fairly complicated and hairy quickly. haskell-ide-engine and haskell-language-server use <a href="https://github.com/DanielG/cabal-helper.git">cabal-helper</a> to query more information about your project to help with this.</p>
<h3 id="haskell-lsp">haskell-lsp</h3>
<p><a href="https://github.com/alanz/haskell-lsp">haskell-lsp</a> provides the transport between the client and the server using the Language Server Protocol. It keeps track of a lot of bookkeeping within the protocol, like request IDs and client/server capabilities, and also provides a virtual file system that mirrors edits coming in from the text editor, before they have saved the actually document. Having this mirror is pretty useful for external tools that need to be run on physical files rather than in-memory text buffers. Its sister library, haskell-lsp-types, provides type definitions for the actual specification, so if you want to do your own thing you don’t need to rewrite the data types and parsing all over again.</p>
<h3 id="lsp-test">lsp-test</h3>
<p><a href="https://github.com/bubba/lsp-test">lsp-test</a> is a testing framework for LSP servers, used by ghcide, HIE and haskell-language-server. It acts as a language client that can be programmed to send messages to servers, and assert that the right messages are received back. It can also be used to recreate certain scenarios: <a href="https://lukelau.me/haskell/posts/leak/">useful for hunting down memory leaks</a>.</p>
<h3 id="ghc-.hie-files">GHC <code>.hie</code> files</h3>
<p>A lot of the work on ghcide and haskell-ide-engine has driven new features and functionality upstream into GHC. One such example is <a href="https://www.haskell.org/ghc/blog/20190626-HIEFiles.html"><code>.hie</code> files</a>. These are generated with the <code>-fwrite-ide-flag</code> during compilation, and like a <code>.hi</code> file they contain additional information about some compiled module. However <code>.hie</code> files contain lots of information specifically useful for tooling, such as the type of expressions or where things are defined, hence the acronym for <em>haskell information extended</em> — not to be confused with haskell-ide-engine! Work is underway to use these files in ghcide to provide much more accurate code navigation, completion and type definitions.</p>
<h3 id="haskell-ide-engine">haskell-ide-engine</h3>
<p>The <a href="https://github.com/haskell/haskell-ide-engine">haskell-ide-engine</a> is a language server that faithfully served as a focal point for a whole suite of tools. It’s been a relatively long-running project: It predates the existence of LSP! It originally used ghc-mod as its backend before switching to hie-bios, and it provides a bunch of logic for extracting code completion and symbols etc. out of the GHC API that eventually got absorbed into ghcide. It also has a plugin system which allows external tools to easily interface with LSP. So built into HIE, Floskell, Ormolu and Brittany can provide formatting whilst GHC, Liquid Haskell and HLint provide diagnostics, all through the same interface.</p>
<h3 id="haskell-language-server">haskell-language-server</h3>
<p><a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a> now aims to concentrate the efforts behind ghcide and haskell-ide-engine. It uses the powerful core of ghcide and HIE’s approach of plugins to integrate an ecosystem worth of tools. Eventually there will be enough tools integrated that users will be able to configure what tools they want to use for each job. Floskell for formatting, or Ormolu? And more importantly, because it builds upon so many components, haskell-language-server will receive any improvements made downstream. This division of labour allows contributors to focus on the individual problems that need tackled, whilst benefiting the whole ecosystem.</p>
<p>Ultimately this means that <strong>haskell-ide-engine is being sunset and users should eventually move to haskell-language-server</strong> when it is ready. <strong>ghcide will continue to be developed</strong> and will serve as the underlying backend that powers haskell-language-server.</p>
<h3 id="looking-forward">Looking forward</h3>
<p>We are now entering the <em>renaissance</em> of Haskell tooling. This summer there are 3 Google Summer of Code projects and a Tweag open source fellowship all working on tooling, as well as the continued efforts of many contributors.</p>
<p><a href="https://github.com/fendor">Fendor</a> is working on supporting compilation of multiple <em>home-packages</em> at once within GHC. In short this will allow tooling to work with multiple components inside a package simultaneously. <a href="http://github.com/bubba">Luke Lau</a> (that’s me) is improving the implicit discovery of cradles in hie-bios by connecting together the <a href="https://github.com/haskell/cabal/pull/6241">Cabal <code>show-build-info</code> command</a>, which will give a much more reliable Cabal setup in the absence of <code>hie.yaml</code> files. <a href="http://github.com/wz1000">Zubin Duggal</a> will be focusing on the haskell-language-server, fleshing out its features and taking advantage of GHC’s <code>.hie</code> files. And <a href="https://github.com/mpardalos">Michalis Pardalos</a> is integrating <a href="https://opentelemetry.io">OpenTelemetry</a> with the language servers, so that we can instrument and profile how they perform on the vast heterogeneous array of LSP clients that they may be used with.</p>
<p>By the end of the summer we will have built a robust language server which works on any Haskell project of any size and built with any build system.</p>
<p>There are a lot of exciting projects in the pipeline, and we will be posting about them here every Friday. In the meantime, come chat with us over at <a href="irc://irc.freenode.net/haskell-ide-engine">#haskell-ide-engine</a> on Freenode, clone some projects and help us build the ultimate Haskell IDE.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>

</feed>
