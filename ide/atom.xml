<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>IDE 2020 Updates</title>
    <link href="http://mpickering.github.io//ide/atom.xml" rel="self" />
    <link href="http://mpickering.github.io/" />
    <id>http://mpickering.github.io//ide/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2020-06-05T00:00:00Z</updated>
    <entry>
    <title>2020-06-05-ghcide-and-nixpkgs</title>
    <link href="http://mpickering.github.io//ide/posts/2020-06-05-ghcide-and-nixpkgs.html" />
    <id>http://mpickering.github.io//ide/posts/2020-06-05-ghcide-and-nixpkgs.html</id>
    <published>2020-06-05T00:00:00Z</published>
    <updated>2020-06-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Getting ghcide into nixpkgs </h2>
<p class="text-muted">
    Posted on June  5, 2020 by <a href="https://github.com/maralorn">Malte Brandy</a>
    <span class="avatar"><img src="/ide/images/maralorn.png"/></span>
</p>

<p>A few weeks ago I got <a href="https://github.com/digital-asset/ghcide">ghcide</a> into <a href="https://nixos.org/nixos">nixpkgs, the package set of the package manager nix and the distribution nixos</a>. Mind you, that was not a brave act of heroism or dark wizardry. Once I grasped the structure of the nixpkgs Haskell ecosystem, it was actually pretty easy. In this post I want to share my experience and tell you what I learned about the nixpkgs Haskell infrastructure and ghcide.</p>
<p>This post has four parts:</p>
<ol type="1">
<li>Why can installing ghcide go wrong?</li>
<li>How can you install ghcide on nix today?</li>
<li>The nixpkgs Haskell ecosystem and dependency resolution</li>
<li>How ghcide got fixed in nixpkgs</li>
</ol>
<!--more-->
<h2 id="why-can-installing-ghcide-go-wrong">1. Why can installing ghcide go wrong?</h2>
<p>Haskell development tooling setup is infamous for being brittle and hard to setup. Every other day when someone asks on reddit or in the <code>#haskell</code> channel, inescapably there will come at least one answer of the form “It’s not worth the pain. Just use ghcid.” I guess one point of this blog series is that this does not have to be the case anymore.</p>
<p>So, what were the reasons for this resignation? One is certainly that <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a> is a really great and easy to use tool. I think it‘s clear that a well done language server can leverage you much further and to me <code>ghcide</code> has already proven this.</p>
<h3 id="compile-your-project-and-ghcide-with-the-same-ghc">Compile your project and ghcide with the same ghc!</h3>
<p>One source of frustration is likely that successfully setting up a language server that is deeply interwoven with <code>ghc</code> like <code>ghcide</code> has one very important requirement. <strong>You need to compile <code>ghcide</code> with the same <code>ghc</code> (version) as your project.</strong> This shouldn‘t be hard to achieve nowadays - I’ll show how to do it if you use <code>nix</code> in this blogpost and I assume it‘s the default in other setups - but if you fail to meet this requirement you are in for a lot of trouble.</p>
<p>So why exactly do we need to use “the same ghc” and what does that even mean? Frankly I am not totally sure. I am not a <code>ghcide</code> developer. I guess sometimes you can get away with some slight deviations, but the general recommendation is to use the same <code>ghc</code> version. I can tell you three situations that will cause problems or have caused problems for me:</p>
<ol type="1">
<li><p>Using another <code>ghc</code> release. E.g. using <code>ghcide</code> compiled with <code>ghc</code> 8.8 on a <code>ghc</code> 8.6 project I get:</p>
<pre class="plain"><code>Step 4/6, Cradle 1/1: Loading GHC Session
ghcide: /nix/store/3ybbc3vag4mpwaqglpdac4v413na3vhl-ghc-8.6.5/lib/ghc-8.6.5/ghc-prim-0.5.3/HSghc-prim-0.5.3.o: unknown symbol `stg_atomicModifyMutVarzh&#39;
ghcide: ghcide: unable to load package `ghc-prim-0.5.3&#39;</code></pre></li>
<li><p>Using the same <code>ghc</code> version but linked against different external libraries like <code>glibc</code>. This <a href="https://github.com/digital-asset/ghcide/issues/404">can happen</a> when <a href="https://github.com/digital-asset/ghcide/issues/538">different releases</a> of nixpkgs are involved. This could look like this:</p>
<pre class="plain"><code>Step 4/6, Cradle 1/1: Loading GHC Session
ghcide: &lt;command line&gt;: can&#39;t load .so/.DLL for: /nix/store/hz3nwwc0k32ygvjn63gw8gm0nf9gprd8-ghc-8.6.5/lib/ghc-8.6.5/ghc-prim-0.5.3/libHSghc-prim-0.5.3-ghc8.6.5.so (/nix/store/6yaj6n8l925xxfbcd65gzqx3dz7idrnn-glibc-2.27/lib/libm.so.6: version `GLIBC_2.29&#39; not found (required by /nix/store/hz3nwwc0k32ygvjn63gw8gm0nf9gprd8-ghc-8.6.5/lib/ghc-8.6.5/ghc-prim-0.5.3/libHSghc-prim-0.5.3-ghc8.6.5.so))</code></pre>
<p>or like this</p></li>
</ol>
<pre class="plain"><code>   Unexpected usage error
   can&#39;t load .so/.DLL for: /nix/store/pnd2kl27sag76h23wa5kl95a76n3k9i3-glibc-2.27/lib/libpthread.so
   (/nix/store/pnd2kl27sag76h23wa5kl95a76n3k9i3-glibc-2.27/lib/libpthread.so.0: undefined symbol:
   __libc_vfork, version GLIBC_PRIVATE)</code></pre>
<ol start="3" type="1">
<li>Using the same <code>ghc</code> release but with a patch to <code>ghc</code>. This e.g. happened to me while using the <a href="https://github.com/obsidiansystems/obelisk"><code>obelisk</code> framework</a> which uses a modified <code>ghc</code>.</li>
</ol>
<p>To sum up, both ghcs should come from the same source and be linked against the same libraries. Your best bet is to use the same binary. But that is not necessary.</p>
<h2 id="how-can-you-install-ghcide-on-nix-today">2. How can you install ghcide on nix today?</h2>
<p>When you want to use <code>ghcide</code> with nix you now have two options. Either <a href="https://nixos.org/nixos/packages.html?query=ghcide"><code>haskellPackages.ghcide</code></a> from nixpkgs or <a href="https://github.com/cachix/ghcide-nix"><code>ghcide-nix</code></a> which uses the <a href="https://github.com/input-output-hk/haskell.nix"><code>haskell.nix</code> ecosystem</a>. I will describe both solutions and their pros and cons from my point of view.</p>
<h3 id="haskellpackages.ghcide">haskellPackages.ghcide</h3>
<p>First make sure you are on a new enough version of nixpkgs. You can try installing <code>ghcide</code> user or system wide, with e.g. <code>nix-env -iA haskellPackages.ghcide</code> or via your <code>configuration.nix</code> on nixos. But that has a greater danger of being incompatible with the <code>ghc</code> you are using in your specific project. The less brittle and more versatile way is to configure <code>ghcide</code> in your projects <code>shell.nix</code>. You probably already have a list with other dev tools you use in there, like <code>with haskellPackages; [ hlint brittany ghcide ]</code>. Just add <code>ghcide</code> in that list and you are good to go. See e.g. <a href="https://discourse.nixos.org/t/nix-haskell-development-2020/6170">this post for a recent discussion about a Haskell dev setup with nix</a>. If you are stuck with an old nixpkgs version, have a look at the end of part 4.</p>
<h4 id="pros">Pros</h4>
<ul>
<li>Easy to setup</li>
<li>Builds ghcide with the same ghc binary as your project, so no danger of incompatabilities between ghc and ghcide.</li>
</ul>
<h4 id="cons">Cons</h4>
<ul>
<li>We only have released versions of ghcide in nixpkgs. If you use nixpkgs-stable it might not even be the last release.</li>
<li>When you use another <code>ghc</code> version than the default in your nixpkgs version, nix will compile ghcide on your computer because it isn‘t build by hydra. (build times are totally fine though.)</li>
</ul>
<h3 id="ghcide-nix">ghcide-nix</h3>
<p>You can import the <code>ghcide-nix</code> repo as a derivation and install the ghcide from there. Consult the README for more details.</p>
<h4 id="pros-1">Pros</h4>
<ul>
<li>Cached binaries for all supported <code>ghc</code> versions via cachix.</li>
<li>Always a recent version from the ghcide master branch.</li>
<li>Definitely recommended when you are already using the <code>haskell.nix</code> infrastructure for your project.</li>
</ul>
<h4 id="cons-1">Cons</h4>
<ul>
<li>Danger of incompatibilities, when your nixpkgs version and the pinned one of <code>ghcide-nix</code> don‘t match.</li>
<li>Not compatible with a patched ghc, which is not build for the <code>haskell.nix</code> infrastructure.</li>
<li>Larger nix store closure.</li>
</ul>
<p><strong>EDIT:</strong> I have been made aware of an alternative method to install <code>ghcide</code> with <code>haskell.nix</code>:</p>
<blockquote>
<p>you can add it to a haskell.nix shell (one created with the <code>shellFor</code> function) with <code>x.shellFor { tools = { ghcide = &quot;0.2.0&quot;; }; }</code>. This will build <code>ghcide</code> with the <code>ghc</code> version in the shell.</p>
</blockquote>
<p>Have a look at the <code>haskell.nix</code> documentation for more details.</p>
<h3 id="configuration-and-setup">Configuration and Setup</h3>
<p>Of course, after installing you need to test <code>ghcide</code> and possible write a <code>hie.yaml</code> file to get <code>ghcide</code> to work with a specific project. This is not very nix specific and will probably change in the future, so I don‘t dive into it right now. Consult the readmes of <a href="https://github.com/digital-asset/ghcide"><code>ghcide</code></a> and <a href="https://github.com/mpickering/hie-bios"><code>hie-bios</code></a>.</p>
<p>There is though one point to note here and that is package discovery. <code>ghcide</code> needs to know all the places that <code>ghc</code> uses to lookup dependencies. When (and I think only when) you use the <code>ghc.withPackages</code> function from <code>nixpkgs</code> the dependencies are provided to <code>ghc</code> via environment variables set in a wrapper script. In general <code>ghcide</code> will not know about this variables and fail to find dependencies. E.g.:</p>
<pre><code>Step 4/6, Cradle 1/2: Loading GHC Session
ghcide: &lt;command line&gt;: cannot satisfy -package-id aeson-1.4.7.1-5lFE4NI0VYBHwz75Ema9FX</code></pre>
<p>To prevent this you need to find a way to set those environment variables when starting <code>ghcide</code>. <a href="https://github.com/NixOS/nixpkgs/pull/89450">I have a PR underway</a> which should do this for you if you install <code>ghcide</code> by putting it in the same <code>withPackages</code> list.</p>
<h2 id="the-nixpkgs-haskell-ecosytem-and-dependency-resolution">3. The nixpkgs Haskell ecosytem and dependency resolution</h2>
<p>This section might be slightly off-topic here, so feel free to skip it. I think this is really useful to know if you work with Haskell and nixpkgs and I regard it as necessary context to understand the fix outlined in part 4.</p>
<h3 id="haskell-dependency-resolution-in-general">Haskell dependency resolution in general</h3>
<p>Dependency resolution problems have a long history in Haskell, but today there are two solutions that both work quite well in general.</p>
<ol type="1">
<li>Specify upper and lower bounds for every dependency in your cabal file and let cabal figure out a build plan. The times of cabal hell are over and this works quite well. Notably this is the way ghcide is supposed to be compiled in general.</li>
<li>Pin a stack LTS release for your dependencies and pin the version for packages not on stackage.</li>
</ol>
<p>Now solution two is in some sense less complex to use, because at compile time you don‘t need to construct a build plan. Of course, as I said, today cabal can do this for you very smoothly, which is why I personally prefer the first approach.</p>
<h3 id="haskell-in-nixpkgs---pkgs.hackagepackages">Haskell in nixpkgs - pkgs.hackagePackages</h3>
<p>So how does nixpkgs do it? Well basically solution two. Everyday <a href="https://github.com/NixOS/nixpkgs/commit/0a566a5777264e58fbfc259cb6453a9685dc5bfb">a cronjob</a> pulls a list of <strong>all packages from a pinned stack LTS release</strong> and creates a derivation for every one of them. It also pulls <strong>all other packages from hackage</strong> and creates a derivation for the <strong>latest released version</strong> of them. (This happens on the <a href="https://github.com/NixOS/nixpkgs/compare/haskell-updates">haskell-updates branch of nixpkgs</a> which get‘s normally merged into nixpkgs master i.e. unstable <a href="https://github.com/NixOS/nixpkgs/pull/88894">once per week</a>. So then, you ask, how does cabal2nix do dependency resolution? Well the short form is, it doesn‘t. What I mean by that is: It completely ignores any version bounds given in a cabal file or a pinned stack LTS release. It will just <strong>take the one version of every dependency that is present in nixpkgs</strong> by the method I told you above.</p>
<p>When I first learned about this I thought this was ludicrous. This is prone to fail. And indeed it does. For a large number of packages the build will either fail at compile time or more often cabal will complain that it can‘t create a build plan. What that actually means: cabal says the one build plan we provided it with is invalid because it does not match the given version bounds. duh. So that packages get automatically marked broken after hydra, the nixos build server, fails to build them. And oh boy, <a href="https://github.com/NixOS/nixpkgs/blob/0a566a5777264e58fbfc259cb6453a9685dc5bfb/pkgs/development/haskell-modules/configuration-hackage2nix.yaml#L2647-L10970">there are a lot of Haskell packages broken in nixpkgs</a>.</p>
<p>Before grasping how this setup comes together, <a href="https://discourse.nixos.org/t/nix-and-the-haskell-eco-system-a-match-made-in-heaven-or-a-difficult-relationship/3314">I was very frustrated by this</a>. And I guess for others casually encountering broken Haskell packages in nixpkgs, without understanding this setup can be annoying.</p>
<p>What could be a suitable alternative to this for nixpkgs? Tough to say. We could try to use some solution like the go, rust or node ecosystem and check in a build plan for every package. Actually that can be a nice solution and if you are interested in that you should definitely checkout the <code>haskell.nix</code> infrastructure. But that really does not go well together with providing all of hackage in nixpkgs. For starters having every version of every Haskell package in nixpkgs would already be very verbose. And Haskell dependency resolution is structured in a way that in one build all dependencies have to agree on the version of mutual further dependencies. That means two build plans that use the same version of one package might still need different builds of that package. As a result it could very well happen that your project could not profit a lot from the nixpkgs binary cache even when it had precompiled every version of every Haskell package.</p>
<p>There can probably be said a lot more about this, but I have accepted that the chosen solution in nixpkgs actually has a lot of advantages (mainly fewer compilation work for everyone) and I actually haven‘t encountered a package I couldn‘t get to build with nixpkgs. The truth is the best guess build plan nixpkgs provides us with is normally not very far away from a working build plan. And it actually is a reasonable build plan. As a Haskell developer I think it is a good rule of thumb to always make your project work with the newest versions of all dependencies on hackage. And then it‘s very likely that your package will also work in nixpkgs.</p>
<p>Above I complained that a lot of Haskell packages are broken in nixpkgs. In truth, all commonly used packages work and most other packages are very easy to fix.</p>
<h2 id="building-ghcide-with-nixpkgs">4. Building ghcide with nixpkgs</h2>
<p>So what can we do to fix a broken package on nixpkgs?</p>
<h3 id="how-to-fix-broken-haskell-builds-in-nixpkgs-in-general">How to fix broken Haskell builds in nixpkgs in general</h3>
<p><a href="https://www.youtube.com/watch?v=KLhkAEk8I20">(Also watch this video if you are interested in this).</a></p>
<ol type="1">
<li>Often the error is actually fixed by an upstream version bound change, so you can always just try to compile the package. If it works make a PR against nixpkgs to remove the broken flag.</li>
<li>Often the problem is that the package can actually build with the supplied build plan but cabal doesn‘t believe us. So we can do a “jailbreak” and just tell cabal to ignore the version constraints. We don‘t do this by default because even if the package builds, it might now have changed semantics because of a change in a dependency. So a jailbreaked package should be tested and reported upstream so that the cabal restrictions of that package can get fixed.</li>
<li>If those two don‘t help we can still override the build plan manually to use different versions of the dependencies, not the ones provided by nixpkgs by default.</li>
</ol>
<p>And the third option is what needed to be done for ghcide.</p>
<h3 id="fixing-the-ghcide-build-in-nixpkgs">Fixing the ghcide build in nixpkgs</h3>
<p>There were the following problems <a href="https://github.com/NixOS/nixpkgs/pull/86659">on nixpkgs-20.03</a>:</p>
<ul>
<li><code>hie-bios</code> was broken because of failing tests. Test fails during nix builds are very often false positives, so I disabled the tests.</li>
<li><code>ghcide</code> needed <code>regex-tdfa</code> and <code>haddock-library</code> newer than in the stack-lts. So I just used newer versions of those two libraries. This was not necessary on the <code>haskell-updates</code> branch because it uses a new enough stack lts release.</li>
<li><code>ghcide</code> pins the version of <code>haskell-lsp</code> and <code>haskell-lsp-types</code>. This will probably be the reason why maintaining <code>ghcide</code> in nixpkgs will always be a little bit of manual work because, it would have to be by chance <em>exactly</em> the <code>haskell-lsp</code> version from the stack lts release, to work without manual intervention.</li>
</ul>
<p>So in summary only very few lines of code were needed to get <code>ghcide</code> to work. If you are curious look at <a href="https://github.com/NixOS/nixpkgs/pull/86765">the commit</a>. It</p>
<ul>
<li>enables the generation of <code>haskell-lsp</code> and <code>haskell-lsp-types</code> 0.19.</li>
<li>uses those packages as dependencies for <code>ghcide</code></li>
<li>disables test for <code>hie-bios</code></li>
<li>and marks <code>ghcide</code> and <code>hie-bios</code> as unbroken.</li>
</ul>
<h3 id="fixing-the-ghcide-build-via-overrides">Fixing the ghcide build via overrides</h3>
<p>Sometimes you are stuck with an older nixpkgs version. E.g. I wanted <code>ghcide</code> to work with my obelisk project. Obelisk uses a pinned nixpkgs version <em>and</em> a patched ghc. So what I did was putting the overrides I describe above as overrides into my projects <code>default.nix</code>. That‘s always a nice way to first figure out how to fix a dependency, but of course you help a lot more people if you find a way to upstream the fixes into nixpkgs.</p>
<p>I had to manually create some of the packages with a function called <code>callHackageDirect</code> because the nixpkgs version in reflex-platform was so old. It’s kinda the last way out, but it is very flexible and should be enough to solve most dependency issues. If nothing else helps, create a build plan with cabal and reproduce it by hand with nix overrides. That actually worked for me, when <a href="https://github.com/obsidiansystems/obelisk/issues/660#issuecomment-594277283">I tried to get ghcide to run with obelisk.</a></p>
<h2 id="final-remarks">Final remarks</h2>
<p>Thank you for following me this long. I hope I have illuminated a bit the situation with getting Haskell packages and <code>ghcide</code> specifically to run under nixpkgs. If someday you meet a broken Haskell package in nixpkgs you now hopefully know why, and how to fix it, or at least that fixing it is probably not hard and you should give it a shot.</p>
<p>Installing <code>ghcide</code> for sure isn’t hard anymore. It even works in fairly custom special case development situations like obelisk. So my recommendation is, set it up right now, you won’t want to work without it anymore.</p>
<p>In this post I have touched a lot of topics, which could all use more concrete how-to explanations, and on all of them I am far from an expert. So if you think something is amiss or if you don’t understand something feel free to contact me and maybe we can clarify it.</p>
<p>A big thank you to everyone involved with ghcide, nixpkgs or obelisk who helped me with figuring all of this out! The nice people you meet are what actually makes all of this so much fun.</p>
<p>I personally am definitely looking forward to the first official release of haskell-language-server and I am sure we can land it in nixpkgs quickly. <a href="https://github.com/NixOS/nixpkgs/pull/89447">ghcide 0.2.0 will probably be merged</a> into <a href="https://github.com/NixOS/nixpkgs/pull/89456">nixpkgs master</a> around the same time that this post is getting released.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-29-hiedb</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-29-hiedb.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-29-hiedb.html</id>
    <published>2020-05-29T00:00:00Z</published>
    <updated>2020-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Responsive IDEs </h2>
<p class="text-muted">
    Posted on May 29, 2020 by <a href="https://github.com/wz1000">Zubin Duggal</a>
    <span class="avatar"><img src="/ide/images/wz1000.png"/></span>
</p>

<p>This is the fourth installment in our weekly series of IDE related updates. I will discuss some of the latest developments with respect to the <strong>ghcide</strong> architecture and how we’ve been working to increase its responsiveness.</p>
<!--more-->
<h2 id="slow-response-times-in-ghcide">Slow response times in ghcide</h2>
<p>A while ago, <a href="https://github.com/digital-asset/ghcide/issues/503">Matthew and others noticed</a> that performance for requests like <em>hovering</em> was still far too slow, especially for big projects like ghc. Furthermore, other requests like completions were also pretty useless, since they took ages to show up, and only did so when you paused while typing.</p>
<p>One of the reasons for this turned out to be the way <strong>ghcide</strong> handled new requests. Only one Shake <code>Action</code> can run with access to the Shake database at a time, so when ever new requests came in, <strong>ghcide</strong> would cancel whatever requests were previously running and schedule the new one. This meant that if you started typing, your most recent modification to the file would cancel any already running typecheck from the previous modifications and run a new one. Then, when a completion request came in, it would even cancel this latest typecheck if it was still running, kick off a new typecheck and finally report results when this succeeded. If the typecheck failed, <strong>ghcide</strong> would still try to use the results of the previous typecheck to give you your results, but, <em>crucially</em>, it has to wait for the previous typecheck to fail before it can do this.</p>
<h3 id="a-new-old-solution">A new old solution</h3>
<p>We already had a pretty good idea about how to fix this problem, especially since <strong>haskell-ide-engine</strong> had usable and fast completions. The key idea was to not make arbitrary requests like hover, goto definition and completion cancel running typechecks. Instead, we always want them to use the results of the last successful typecheck. This trades off some correctness for responsiveness, since if a typecheck is running, these requests will not wait for the typecheck to complete before reporting results, and just use the results of the previous typecheck.</p>
<p>In addition to this, we maintain a queue of requests to schedule with shake, and add <code>Action</code>s to this queue to refresh whatever information from the database was accessed by our requests, so that the database is always kept up to date.</p>
<p>This solution was implemented by Matthew, and you can use it by running <a href="https://github.com/mpickering/ghcide/">his branch of <strong>ghcide</strong></a>. This is also the branch of <strong>ghcide</strong> used by <a href="https://github.com/haskell/haskell-language-server"><strong>haskell-language-server</strong></a>.</p>
<h3 id="no-more-waiting-for-your-ide-to-catch-up-to-you">No more waiting for your IDE to catch up to you</h3>
<p>As covered in earlier blog posts, I have been working on integrating <a href="https://github.com/wz1000/hiedb"><strong>hiedb</strong></a> with <strong>ghcide</strong> so that it can display project wide references. While doing this, I was reminded of the <a href="https://clangd.llvm.org/design/indexing.html">architecture</a> of the <a href="https://clangd.llvm.org/">clangd</a> language server, and I realised that many other requests could be served using this model.</p>
<p>The idea is for <strong>ghcide</strong> to act as an indexing service for <strong>hiedb</strong>, generating <code>.hi</code> and <code>.hie</code> files which are indexed and saved in the database, available for all future queries, even across restarts. A local cache of <code>.hie</code> files/typechecked modules is maintained on top of this to answer queries for the files the user is currently editing. All information that is not in some sense “local” to a particular module is accessed through the database. On the other hand, information like the symbol under a point, the references and types of local variables etc. will be accessed through the local cache.</p>
<p>A goal we would like to work towards would be to have an instantly responsive IDE as soon as you open your editor. Ideally, we wouldn’t even want to wait for your code to typecheck before your IDE is usable. Indeed, on my branch of <strong>ghcide</strong>, many features are available instantly, provided a previous run had cached a <code>.hie</code> file for your module on disk.</p>
<script id="asciicast-xkqfc5Fst9yC5gDaPskiNE5au" src="https://asciinema.org/a/xkqfc5Fst9yC5gDaPskiNE5au.js" async></script>
<p>Here you can see that we can use the <code>hover</code> and <code>go to definition</code> features as soon as we open our editor, even on a big project like GHC which takes quite a while to typecheck.</p>
<p>The hover, go to (type) definition, references, document highlight and workspace symbols requests have been (re)written to fit this model. We can even teach <strong>hiedb</strong> to index <code>.hi</code> files, so that module imports, identifiers exported from modules, their types and their documentation are also stored in the database. We can then use this info to serve completion requests.</p>
<p>You can follow along with my progess <a href="https://github.com/wz1000/ghcide/tree/hiedb">here</a>.</p>
<h3 id="space-leaks-and-shake-responsiveness">Space leaks and shake responsiveness</h3>
<p>The un-intuitive behaviour of the GHC and Shake schedulers was responsible for some of the delay while answering requests. It seems like neither’s behaviour is quite optimal for the kinds of workloads <strong>ghcide</strong> generates, which consist of many extremely short running actions.</p>
<p>You can read more about this and Neil’s investigation into it in his <a href="https://neilmitchell.blogspot.com/2020/05/fixing-space-leaks-in-ghcide.html">blog post</a></p>
<h2 id="other-developments">Other developments</h2>
<p>The students accepted for IDE related GSOCs (Luke, Fendor and Michalis) have been gearing up for the official start of their program on the coming Monday.</p>
<ul>
<li>Javier Niera has been looking into the <strong>haskell-language-server</strong> CI and testsuite, as well as porting over the old <strong>haskell-ide-engine</strong> README instructions, so that people can quickly get it set up on their own editors</li>
<li>Fendor has picked up an old <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/1425">GHC MR</a> to reimplement ghci’s <code>:set +c</code> functionality using <code>.hie</code> files</li>
<li>Luke Lau has been working on adding the ability to <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3330">attach haddocks to declarations generated by TH</a> as a yak shave while working on <a href="https://github.com/alanz/haskell-lsp/pull/244">improvements to the <strong>haskell-lsp</strong></a> library</li>
</ul>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-27-ghcide-space-leaks</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-27-ghcide-space-leaks.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-27-ghcide-space-leaks.html</id>
    <published>2020-05-27T00:00:00Z</published>
    <updated>2020-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Fixing Space Leaks in Ghcide </h2>
<p class="text-muted">
    Posted on May 27, 2020 by <a href="https://github.com/ndmitchell">Neil Mitchell</a>
    <span class="avatar"><img src="/ide/images/ndmitchell.png"/></span>
</p>

<h1 id="fixing-space-leaks-in-ghcide">Fixing Space Leaks in Ghcide</h1>
<p>This blog post was first posted on <a href="http://neilmitchell.blogspot.com/2020/05/fixing-space-leaks-in-ghcide.html">Neil’s own blog</a> and is cross-posted here.</p>
<p>Over the bank holiday weekend, I decided to devote some time to a possible <a href="https://shakebuild.com/">Shake build system</a> performance issue in <a href="https://github.com/digital-asset/ghcide">Ghcide Haskell IDE</a>. As I started investigating (and mostly failed) I discovered a space leak which I eventually figured out, solved, and then (as a happy little accident) got a performance improvement anyway. This post is a tale of what I saw, how I tackled the problem, and how I went forward. As I’m writing the post, not all the threads have concluded. I wrote lots of code during the weekend, but most was only to experiment and has been thrown away - I’ve mostly left the code to the links. Hopefully the chaotic nature of development shines through.</p>
<h2 id="shake-thread-pool-performance">Shake thread-pool performance</h2>
<p>I started with <a href="https://github.com/ndmitchell/shake/pull/751">a Shake PR</a> claiming that simplifying the Shake thread pool could result in a performance improvement. Faster and simpler seems like a dream combination. Taking a closer look, simpler seemed like it was simpler because it supported less features (e.g. ability to kill all threads when one has an exception, some fairness/scheduling properties). But some of those features (e.g. better scheduling) were in the pursuit of speed, so if a simpler scheduler was 30% faster (the cost of losing randomised scheduling), that might not matter.</p>
<p>The first step was to <a href="https://github.com/ndmitchell/shake/pull/751#issuecomment-632634439">write a benchmark</a>. It’s very hard to synthesise a benchmark that measures the right thing, but spawning 200K short tasks into the thread pool seemed a plausible start. As promised on the PR, the simpler version did indeed run faster. But interestingly, the simplifications weren’t really responsible for the speed difference - switching from <code>forkIO</code> to <code>forkOn</code> explained nearly all the difference. I’m not that familiar with <code>forkOn</code>, so decided to micro-benchmark it - how long does it take to spawn off 1M threads with the two methods. I found two surprising results:</p>
<ul>
<li>The performance of <code>forkOn</code> was quadratic! A <a href="https://gitlab.haskell.org/ghc/ghc/issues/18221">GHC bug</a> explains why - it doesn’t look too hard to fix, but relying on <code>forkOn</code> is unusual, so its unclear if the fix is worth it.</li>
<li>The performance of <code>forkIO</code> was highly inconsistent. Often it took in the region of 1 second. Sometimes it was massively faster, around 0.1s. A <a href="https://stackoverflow.com/questions/61971292/ghc-forkio-bimodal-performance">StackOverflow question</a> didn’t shed much light on <em>why</em>, but did show that by using the <a href="https://hackage.haskell.org/package/pvar/docs/Data-Primitive-PVar.html#t:PVar"><code>PVar concurrency primitive</code></a> it could be 10x faster. There is a <a href="https://gitlab.haskell.org/ghc/ghc/issues/18224">GHC bug tracking the issue</a>, and it seems as though the thread gets created them immediately switches away. There is a suggestion from Simon Peyton Jones of a heuristic that might help, but the issue remains unsolved.</li>
</ul>
<p>My desire to switch the Shake thread-pool to a quadratic primitive which is explicitly discouraged is low. Trying to microbenchmark with primitives that have inconsistent performance is no fun. The hint towards <code>PVar</code> is super interesting, and I may follow up on it in future, but given the remarks in the GHC tickets I wonder if <code>PVar</code> is merely avoiding one small allocation, and avoiding an allocation avoids a context switch, so it’s not a real signal.</p>
<p>At this point I decided to zoom out and try benchmarking all of Ghcide.</p>
<h2 id="benchmarking-ghcide">Benchmarking Ghcide</h2>
<p>The thread about the Shake thread pool pointed at <a href="https://github.com/digital-asset/ghcide/issues/503">a benchmarking approach</a> of making hover requests. I concluded that making a hover request with no file changes would benchmark the part of Shake I thought the improved thread-pool was most likely to benefit. I used the Shake source code as a test bed, and opened a file with 100 transitive imports, then did a hover over the <code>listToMaybe</code> function. I know that will require Shake validating that everything is up to date, and then doing a little bit of hover computation.</p>
<p>I knew I was going to be running Ghcide a lot, and the Cabal/Stack <code>build</code> steps are frustratingly slow. In particular, every time around Stack wanted to unregister the Ghcide package. Therefore, I wrote a simple <code>.bat</code> file that <a href="https://gist.github.com/ndmitchell/11467985dbf1855e62035fa97248a585#file-test-bat">compiled Ghcide and my benchmark</a> using <code>ghc --make</code>. So I could experiment quickly with changes to Shake, I pulled in all of Shake as source, not as a separate library, with an include path. I have run that benchmark 100’s of times, so the fact it is both simple (no arguments) and as fast as I could get has easily paid off.</p>
<p>For the benchmark itself, I first went down the route of looking at the <a href="https://hackage.haskell.org/package/lsp-test/docs/Language-Haskell-LSP-Test-Replay.html#v:replaySession">replay functionality</a> in <a href="https://hackage.haskell.org/package/lsp-test">lsp-test</a>. Sadly, that code doesn’t link to anything that explains how to <em>generate</em> traces. After asking on the <a href="https://webchat.freenode.net/?channels=haskell-ide-engine">haskell-ide-engine IRC</a> I got pointed at both the existing functionality of <a href="https://hackage.haskell.org/package/haskell-lsp-0.22.0.0/docs/Language-Haskell-LSP-Core.html#v:resCaptureFile"><code>resCaptureFile</code></a>. I also got pointed at the <a href="https://github.com/alanz/haskell-lsp/pull/247/files">vastly improved version in a PR</a>, which doesn’t fail if two messages race with each other. Configuring that and running it on my benchmark in the IDE told me that the number of messages involved was tiny - pretty much an initialisation and then a bunch of hovers. Coding those directly in <code>lsp-test</code> was trivial, and so <a href="https://gist.github.com/ndmitchell/11467985dbf1855e62035fa97248a585#file-benchmark-hs">I wrote a benchmark</a>. The essence was:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">doc <span class="ot">&lt;-</span> openDoc <span class="st">&quot;src/Test.hs&quot;</span> <span class="st">&quot;haskell&quot;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">(t, _) <span class="ot">&lt;-</span> duration <span class="fu">$</span> replicateM_ <span class="dv">100</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    getHover doc <span class="fu">$</span> <span class="dt">Position</span> <span class="dv">127</span> <span class="dv">43</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">print t</a></code></pre></div>
<p>Open a document. Send 100 hover requests. Print the time taken.</p>
<h2 id="profiling-ghcide">Profiling Ghcide</h2>
<p>Now I could run 100 hovers, I wanted to use the GHC profiling mechanisms. Importantly, the 100 hover requests dominates the loading by a huge margin, so profiles would focus on the right thing. I ran a profile, but it was empty. Turns out the way <code>lsp-test</code> invokes the binary it is testing means it kills it too aggressively to allow GHC to write out profiling information. I changed the benchmark to send a shutdown request at the end, then sleep, and changed Ghcide to abort on a shutdown, so it could write the profiling information.</p>
<p>Once I had the profiling information, I was thoroughly uniformed. 10% went in file modification checking, which <a href="https://github.com/digital-asset/ghcide/issues/583">could be eliminated</a>. 10% seemed to go to hash table manipulations, which seemed on the high side, but not too significant (turned out I was totally wrong, read to the end!). Maybe 40% went in the Shake monad, but profiling exaggerates those costs significantly, so it’s unclear what the truth is. Nothing else stood out, but earlier testing when profiling <code>forkIO</code> operations had shown they weren’t counted well, so that didn’t mean much.</p>
<h2 id="prodding-ghcide">Prodding Ghcide</h2>
<p>In the absence of profiling data, I started changing things and measuring the performance. I tried a bunch of things that made no difference, but some things did have an impact on the time to do 100 hovers:</p>
<ul>
<li>Running normally: 9.77s. The baseline.</li>
<li>Switching to <code>forkOn</code>: 10.65s. Suggestive that either Ghcide has changed, or the project is different, or platform differences mean that <code>forkOn</code> isn’t as advantageous.</li>
<li>Using only one Shake thread: 13.65s. This change had been suggested in one ticket, but made my benchmark worse.</li>
<li>Avoid spawning threads for things I think will be cheap: 7.49s. A useful trick, and maybe one that will be of benefit in future, but for such a significant change a 25% performance reduction seemed poor.</li>
<li>Avoid doing any Shake invalidation: 0.31s. An absolute lower bound if Shake cheats and does nothing.</li>
</ul>
<p>With all that, I was a bit dejected - performance investigation reveals nothing of note was not a great conclusion from a days work. I think that other changes to Ghcide to <a href="https://github.com/digital-asset/ghcide/pull/554">run Shake less</a> and <a href="https://github.com/wz1000/ghcide/tree/hiedb">cache data more</a> will probably make this benchmark even less important, so the conclusion worsens - performance investigation of nothing of note reveals nothing of note. How sad.</p>
<p>But in my benchmark I did notice something - a steadily increasing memory size in process explorer. Such issues are pretty serious in an interactive program, and <a href="https://github.com/digital-asset/ghcide/pull/557">we’d fixed several issues recently</a>, but clearly there were more. Time to change gears.</p>
<h2 id="space-leak-detection">Space leak detection</h2>
<p>Using the benchmark I observed a space leak. But the program is huge, and manual code inspection usually needs a 10 line code fragment to have a change. So I started modifying the program to do less, and continued until the program did as little as it could, but still leaked space. After I fixed a space leak, I zoomed out and saw if the space leak persisted, and then had another go.</p>
<p>The first investigation took me into the Shake Database module. I found that if I ran the Shake script to make everything up to date, but did no actions inside, then there was a space leak. Gradually commenting out lines (over the course of several hours) eventually took me to:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">step <span class="ot">&lt;-</span> pure <span class="fu">$</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="dt">Just</span> (_, <span class="dt">Loaded</span> r) <span class="ot">-&gt;</span> incStep <span class="fu">$</span> fromStepResult r</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    _ <span class="ot">-&gt;</span> <span class="dt">Step</span> <span class="dv">1</span></a></code></pre></div>
<p>This code increments a step counter on each run. In normal Shake this counter is written to disk each time, which forces the value. In Ghcide we use Shake in memory, and nothing ever forced the counter. The change was simple - replace <code>pure</code> with <code>evaluate</code>. This fix has been <a href="https://github.com/ndmitchell/shake/commit/8da74bab4a2466b52f8ddc50b75a56139eecb273">applied to Shake HEAD</a>.</p>
<h2 id="space-leak-detection-2">Space leak detection 2</h2>
<p>The next space leak took me to the Shake database <code>reset</code> function, which moves all Shake keys from <code>Ready</code> to <code>Loaded</code> when a new run starts. I determined that if you didn’t run this function, the leak went away. I found a few places I should have <a href="https://github.com/ndmitchell/shake/commit/04b0fb349a5e8ff84c073f9751bcef11b3928570">put strictness annotations</a>, and a function that <a href="https://github.com/ndmitchell/shake/commit/ddf5e2d2020decc44f08c2d5482b8941c5c6d816">mutated an array lazily</a>. I reran the code, but the problem persisted. I eventually realised that if you don’t call <code>reset</code> then none of the user rules run either, which was really what was fixing the problem - but I committed the improvements I’d made even though they don’t fix any space leaks.</p>
<p>By this point I was moderately convinced that Shake wasn’t to blame, so turned my attention to the user rules in Ghcide. I stubbed them out, and the leak went away, so that looked plausible. There were 8 types of rules that did meaningful work during the hover operation (things like <code>GetModificationTime</code>, <code>DoesFileExist</code>, <code>FilesOfInterest</code>). I picked a few in turn, and found they all leaked memory, so picked the simple <code>DoesFileExist</code> and looked at what it did.</p>
<p>For running <code>DoesFileExist</code> I wrote a very quick “bailout” version of the rule, equivalent to the “doing nothing” case, then progressively enabled more bits of the rule before bailing out, to see what caused the leak. The bailout looked like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">Just</span> v <span class="ot">&lt;-</span> getValues state key file</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">let</span> bailout <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">RunResult</span> <span class="dt">ChangedNothing</span> old <span class="fu">$</span> <span class="dt">A</span> v</a></code></pre></div>
<p>I progressively enabled more and more of the rule, but even with the whole rule enabled, the leak didn’t recur. At that point, I realised I’d introduced a syntax error and that all my measurements for the last hour had been using a stale binary. Oops. I span up a copy of <a href="https://github.com/ndmitchell/ghcid">Ghcid</a>, so I could see syntax errors more easily, and repeated the measurements. Again, the leak didn’t recur. Very frustrating.</p>
<p>At that point I had two pieces of code, one which leaked and one which didn’t, and the <em>only</em> difference was the unused <code>bailout</code> value I’d been keeping at the top to make it easier to quickly give up half-way through the function. Strange though it seemed, the inescapable conclusion was that <code>getValues</code> must somehow be fixing the space leak.</p>
<p>If <code>getValues</code> fixes a leak, it is a likely guess that <code>setValues</code> is causing the leak. I modified <code>setValues</code> to also call <code>getValues</code> and the problem went away. But, after hours of staring, I couldn’t figure out why. The code of <code>setValues</code> read:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">setValues state key file val <span class="fu">=</span> modifyVar_ state <span class="fu">$</span> \vals <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    evaluate <span class="fu">$</span> HMap.insert (file, <span class="dt">Key</span> key) (fmap toDyn val) vals</a></code></pre></div>
<p>Namely, modify a strict <code>HashMap</code> from <a href="https://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a>, forcing the result. After much trial and error I determined that a “fix” was to add:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">case</span> HMap.lookup k res <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> pure ()</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="dt">Just</span> v <span class="ot">-&gt;</span> void <span class="fu">$</span> evaluate v</a></code></pre></div>
<p>It’s necessary to insert into the strict <code>HashMap</code>, then do a <code>lookup</code>, then evaluate the result that comes back, or there is a space leak. I duly <a href="https://github.com/digital-asset/ghcide/pull/586">raised a PR to Ghcide</a> with the unsatisfying comment:</p>
<blockquote>
<p>I’m completely lost, but I do have a fix.</p>
</blockquote>
<p>It’s nice to fix bugs. It’s better to have some clue why a fix works.</p>
<h2 id="space-leak-in-hashmap">Space leak in <code>HashMap</code></h2>
<p>My only conclusion was that <code>HashMap</code> must have a space leak. I took a brief look at the code, but it was 20+ lines and nothing stood out. I wrote a benchmark that inserted billions of values at 1000 random keys, but it didn’t leak space. I puzzled it over in my brain, and then about a day later inspiration struck. One of the cases was to deal with collisions in the <code>HashMap</code>. Most <code>HashMap</code>’s don’t have any collisions, so a bug hiding there could survive a very long time. I wrote a benchmark with colliding keys, and lo and behold, it leaked space. Concretely, it leaked 1Gb/s, and brought my machine to its knees. The benchmark inserted three keys all with the same hash, then modified one key repeatedly. I posted the <a href="https://github.com/tibbe/unordered-containers/issues/254">bug to the <code>unordered-containers</code> library</a>.</p>
<p>I also looked at the code, figured out why the space leak was occurring, and a potential fix. However, the fix requires duplicating some code, and its likely the same bug exists in several other code paths too. The <code>Lazy</code> vs <code>Strict</code> approach of <code>HashMap</code> being dealt with as an outer layer doesn’t quite work for the functions in question. I took a look at the PR queue for <code>unordered-containers</code> and saw 29 requests, with the recent few having no comments on them. That’s a bad sign and suggested that spending time preparing a PR might be in vain, so I didn’t.</p>
<p>Aside: Maintainers get busy. It’s no reflection negatively on the people who have invested lots of time on this library, and I thank them for their effort! Given <a href="https://packdeps.haskellers.com/reverse/unordered-containers">1,489 packages on Hackage</a> depend on it, I think it could benefit from additional bandwidth from someone.</p>
<h2 id="hash-collisions-in-ghcide">Hash collisions in Ghcide</h2>
<p>While hash collisions leading to space leaks is bad, having hash collisions at all is also bad. I augmented the code in Ghcide to print out hash collisions, and saw collisions between <code>(&quot;Path.hs&quot;, Key GetModificationTime)</code> and <code>(&quot;Path.hs&quot;, Key DoesFileExist)</code>. Prodding a bit further I saw that the <code>Hashable</code> instance for <code>Key</code> only consulted its argument value, and given most key types are simple <code>data Foo = Foo</code> constructions, they all had the same hash. The solution was to mix in the type information stored by <code>Key</code>. I changed to the definition:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">hashWithSalt salt (<span class="dt">Key</span> key) <span class="fu">=</span> hashWithSalt salt (typeOf key) <span class="ot">`xor`</span> hashWithSalt salt key</a></code></pre></div>
<p>Unfortunately, that now gave hash collisions with different paths at the same key. I looked into the hashing for the path part (which is really an <code>lsp-haskell-types</code> <code>NormalizedFilePath</code>) and saw that it used an optimised hashing scheme, precomputing the hash, and returning it with <code>hash</code>. I also looked at the <code>hashable</code> library and realised the authors of <code>lsp-haskell-types</code> hadn’t implemented <code>hashWithSalt</code>. If you don’t do that, a generic instance is constructed which deeply walks the data structure, completely defeating the <code>hash</code> optimisation. A <a href="https://github.com/alanz/haskell-lsp/pull/248">quick PR fixes that</a>.</p>
<p>I also found that for tuples, the types are combined by using the <code>salt</code> argument. Therefore, to hash the pair of path information and <code>Key</code>, the <code>Key</code> <code>hashWithSalt</code> gets called with the <code>hash</code> of the path as its salt. However, looking at the definition above, you can imagine that both <code>hashWithSalt</code> of a type and <code>hashWithSalt</code> of a key expand to something like:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">hashWithSalt salt (<span class="dt">Key</span> key) <span class="fu">=</span> salt <span class="ot">`xor`</span> hash (typeOf key) <span class="ot">`xor`</span> (salt <span class="ot">`xor`</span> <span class="dv">0</span>)</a></code></pre></div>
<p>Since <code>xor</code> is associative and commutative, those two <code>salt</code> values cancel out! While I wasn’t seeing complete cancellation, I was seeing quite a degree of collision, so I changed to:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">hashWithSalt salt (<span class="dt">Key</span> key) <span class="fu">=</span> hashWithSalt salt (typeOf key, key)</a></code></pre></div>
<p>With that <a href="https://github.com/digital-asset/ghcide/pull/588">fix in Ghcide</a>, all collisions went away, and all space leaks left with them. I had taken this implementation of hash combining from Shake, and while it’s not likely to be a problem in the setting its used there, <a href="https://github.com/ndmitchell/shake/commit/297c60fa0c6b0d4e98f61b9cdb1359a409cda901">I’ve fixed it in Shake too</a>.</p>
<h2 id="benchmarking-ghcide-1">Benchmarking Ghcide</h2>
<p>With the hash collisions reduced, and the number of traversals when computing a hash reduced, I wondered what the impact was on performance. A rerun of the original benchmark showed the time had reduced to 9.10s - giving a speed up of about 5%. Not huge, but welcome.</p>
<p>Several days later we’re left with less space leaks, more performance, and hopefully a better IDE experience for Haskell programmers. I failed in what I set out to do, but found some other bugs along the way, leading to 9 PRs/commits and 4 ongoing issues. I’d like to thank everyone in the Haskell IDE team for following along, making suggestions, confirming suspicions, and generally working as a great team. <a href="https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html">Merging the Haskell IDE efforts</a> continues to go well, both in terms of code output, and team friendliness.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-22-tracing-plan</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-22-tracing-plan.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-22-tracing-plan.html</id>
    <published>2020-05-22T00:00:00Z</published>
    <updated>2020-05-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Adding tracing to ghcide </h2>
<p class="text-muted">
    Posted on May 22, 2020 by <a href="https://github.com/mpardalos">Michalis Pardalos</a>
    <span class="avatar"><img src="/ide/images/mpardalos.png"/></span>
</p>

<p>Welcome to the third post on the ongoing work on a unified Haskell IDE. This week I will be talking about my Google Summer of Code project to <em>introduce tracing into ghcide</em> using OpenTelemetry. I will explain the motivation for this project and then explain what it actually entails, as well as what improvements you should expect to see as a result of it.</p>
<figure>
<img src="/ide/images/trace-example.png" alt="A ghcide trace viewed in chrome’s about:tracing" style="width:100.0%" /><figcaption>A ghcide trace viewed in chrome’s about:tracing</figcaption>
</figure>
<!--more-->
<h3 id="what-is-the-problem">What is the problem?</h3>
<p>The internal architecture of ghcide is based on the <a href="https://shakebuild.com">Shake</a> build system. This is a tool similar in principle to UNIX make, except implemented as a Haskell library. While using a build tool as the core of an IDE might be surprising, it simplifies the internals of the engine, and allows for reuse of information. This is a big contributor to ghcide’s speed. A more detailed explanation is given <a href="https://4ta.uk/p/shaking-up-the-ide">here</a>.</p>
<p>It’s not all rosy though. In order for shake to provide these benefits, it must entirely (with some caveats) control the execution of the IDE engine. Shake loads/parses/typechecks files whenever it sees fit, based on which files have changed and what is requested by the editor. This means that reasoning about performance becomes much harder. It’s hard to tell what action is slow when you don’t know or directly control which ones are running.</p>
<h3 id="so-what-are-you-doing-about-it">So what are you doing about it?</h3>
<p>Addressing this problem is the core of my Google Summer of Code project: I will be introducing tracing to ghcide. This essentially amounts to wrapping interesting sections of code in <code>print &quot;begin &lt;section&gt;&quot;</code> and <code>print &quot;end &lt;section&gt;&quot;</code>, albeit in a slightly more sophisticated way. This will allow us to track which sections are running at any given time and for how long. I will be doing this using <a href="https://opentelemetry.io/">opentelemetry</a> and Dmitry Ivanov’s (@ethercrow) <code>haskell-opentelemetry</code> library, allowing for better tooling support over simple console logging.</p>
<p>OpenTelemetry is a set of tools and APIs for monitoring applications in a variety of ways. We will be using its tracing portion which will allow us to view traces from ghcide in any opentelemetry-compatible viewer, like <a href="https://jaegertracing.io/">Jaeger</a> or Google Chrome’s <code>about:tracing</code>. So, to address some confusion from the reddit comments on last week’s post: This has nothing to do with telemetry, as used in e.g. Visual Studio Code or Windows. It is explicitly opt-in and does not transmit any data over the network.</p>
<p>Matthew Pickering (@mpickering) has already started this effort. He has added initial support for tracing allowing us to get some basic traces. You can see an example of what is possible below:</p>
<p align="center">
<img src="/ide/images/trace-example.png" alt="A ghcide trace viewed in chrome’s about:tracing" style="width:100.0%" />
</p>
<p>This is a trace of ghcide running on GHC. Each bar represents a Shake Action, which is described by the text on the bar. For example the first bar represents loading the first file when the editor was started. You can see that we get no detail beyond how long the entire action took. We can’t tell if certain dependent modules took more or less time, or if the loading was properly parallelised.</p>
<p>The way shake works is that you issue <em>Actions</em> to be run, which can then request data, which based on <em>rules</em> is computed using other Actions, etc. We can currently only trace the initial actions, not any of their dependencies. For example, we know can see how long going to definition takes in its entirety, but not how much of that time was spent loading or parsing files. Adding this will give us a complete picture of what ghcide is doing, and is what I will be adding to ghcide’s tracing.</p>
<h2 id="thats-great-and-all-but-what-do-i-get">That’s great and all, but what do I get?</h2>
<p>Great question! Indeed, this is a developer-facing feature. We are not expecting users of ghcide to be looking at traces. We are hoping however it will guide us towards a faster ghcide by showing us what parts are worth improving. It should also make locating certain classes of bugs easier by showing us if Shake is doing what we are expecting it to.</p>
<h3 id="other-updates">Other Updates</h3>
<p>As always, we have all been working on other projects as well this week.</p>
<ul>
<li>Luke Lau has been <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3330">implementing support</a> for adding haddock documentation to functions using template-haskell to resolve a long standing GHC ticket.</li>
<li>Fendor submitted his first <a href="https://gitlab.haskell.org/ghc/ghc/-/merge_requests/3327">GHC patch</a> getting up to speed for the summer’s project.</li>
<li>Matthew Pickering has been finishing off the <a href="https://github.com/digital-asset/ghcide/pull/522">multi component patch</a> with the careful review of Moritz and Pepe. It looks like it will be merged within the next week.</li>
<li>Avi Dessauer released the first version of <a href="https://hackage.haskell.org/package/implicit-hie">implicit-hie</a> which attempts to generate hie.yaml files for you.</li>
<li>Zubin Duggal has continued working on integrating hie files into his fork of ghcide. You can read more about this in Zubin’s blog post next week.</li>
</ul>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-15-multiple-components</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-15-multiple-components.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-15-multiple-components.html</id>
    <published>2020-05-15T00:00:00Z</published>
    <updated>2020-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Weekly Update and Multiple Components </h2>
<p class="text-muted">
    Posted on May 15, 2020 by <a href="https://github.com/fendor">Fendor</a>
    <span class="avatar"><img src="/ide/images/fendor.png"/></span>
</p>

<p>This is the second blog post in this year’s series of IDE blog posts. In this blog post I will first present the progress we made during the last week, what we have been working on, what has been implemented, and what has been fixed. In the second section I will give some insights on why Haskell IDE Engine is in the retirement process. It explains the shortcomings of its structure and why ghcide supersedes it. In the last section, I will explain the motivation for implementing multiple home packages for GHC and how it, hopefully, will benefit IDEs and every-day users of GHC.</p>
<p><a href="https://gifyu.com/image/nkjS"><img src="https://s6.gifyu.com/images/JumpToInstance.gif" alt="Jump To Instance Definition" /></a></p>
<!--more-->
<h2 id="this-week">This week</h2>
<p>A week has passed since the introduction to the state of IDEs in Haskell. A lot has happened in this one week and I am here to tell you about a few things in detail!</p>
<h3 id="support-for-ghc-8.10.1">Support for GHC 8.10.1</h3>
<p>Maintaining an IDE is a lot of work and we couldn’t do it without the work of volunteers. Part of the maintenance work is updating dependencies and fixing any errors that might occur! This week, as during countless weeks before that, Javier Neira (@jneira) took care of a lot of maintenance work such as responding to issues, fixing bugs and updating Haskell Language Server to be compatible with GHC 8.10.1! Updating Haskell Language Server to support a new GHC version is a huge effort, as it has plenty of dependencies and all of these need to be updated in order to support the newer version.</p>
<h3 id="references">References</h3>
<p><strong>Disclaimer</strong> This feature hasn’t been merged, yet, due to issues with older GHC versions.</p>
<p>Modern IDEs need to be capable of showing you all references to a function, where it is implemented and intelligent code search in general. It should not be necessary to query the function name throughout the whole project to find the implementation. While code-actions such as “Go to Definition” and “Go to Type Definition” have been working for some time now, searching for all references of an identifier has not been implemented as of yet.</p>
<p>But this is bound to change soon! Zubin Duggal developed a working implementation of finding references in a project based on <a href="https://github.com/wz1000/hiedb">hiedb</a>. <code>hiedb</code> is powered by <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/hie-files">HIE</a> files, which are basically very verbose compiler artefacts that can be used to query references, the type of an expression, and a lot of other things (see projects such as <a href="https://hackage.haskell.org/package/weeder">weeder</a>).</p>
<p>Below is a working example of how these HIE files can be used:</p>
<p><a href="https://gifyu.com/image/nkzg"><img src="https://s6.gifyu.com/images/References.gif" alt="Find References" style="width:100.0%" /></a></p>
<p>It allows developers to look for all usages of a function or type and to see all usages of a parameter or definition within a function!</p>
<h3 id="jump-to-instance-definition">Jump to Instance Definition</h3>
<p><strong>Disclaimer</strong> This feature is not yet merged into GHC, but will probably ship with GHC 8.12.</p>
<p>It is well known that you can jump to function definitions in Haddock. For functions that are part of a type-class, you jump to the type-class declaration. However, that is usually not what you want. Thus, Zubin Duggal has implemented a new feature that will allow you to jump to the specific instance definition used by an overloaded function.</p>
<p><a href="https://gifyu.com/image/nkjS"><img src="https://s6.gifyu.com/images/JumpToInstance.gif" alt="Jump To Instance Definition" /></a></p>
<p>This is a really useful feature and will make it easier to explore a code base! Moreover, it can make the IDE experience smoother for developers. LSP supports returning multiple locations for go-to definition requests which we could exploit to give the user a choice about where to jump to.</p>
<h3 id="first-step-towards-open-telemetry-support">First step towards <code>Open Telemetry</code> support</h3>
<p>We are happy to announce that the first <a href="https://github.com/mpickering/ghcide/pull/26">Pull Request</a> of Michalis (@mpardalos) has been merged to Haskell Language Server!</p>
<p>It is a small step compared to the big task ahead to provide telemetry data of IDEs such as the Haskell Language Server. The final goal is to gain insight into the performance of big projects and optimising bottlenecks. To accomplish this, <a href="https://opentelemetry.io/">Open Telemetry</a> will be used to emit relevant performance information. Very recently, the <a href="https://hackage.haskell.org/package/opentelemetry">opentelemetry</a> package was added to Hackage by Dmitry Ivanov (@ethercrow) which will aid the task.</p>
<h3 id="memorable-bug-fixes">Memorable Bug-Fixes</h3>
<p>I will now highlight some of the most memorable bugs we fixed this week, when working on the Haskell Language Server.</p>
<h4 id="completions">Completions</h4>
<p>Since the last blog post, we were informed that there were no completions being provided by the Haskell Language Server, although there are completions when using ghcide. What happened here? Why did Haskell Language Server not use the completion system of ghcide?</p>
<p>The answer was, the completion plugin had not been enabled. Thank you @korayal for providing the <a href="https://github.com/haskell/haskell-language-server/pull/107">fix</a> to this issue!</p>
<p>As an interesting side-note, the completion system of ghcide is almost the same as the one from Haskell IDE Engine! It was ported to ghcide (with some tweaks) and now found its way back into Haskell Language Server.</p>
<h4 id="bad-interface-files">Bad Interface Files</h4>
<p>A particularly nasty bug occured when cached interface files were out of sync. The details of how a project is loaded are described later, but for now it suffices to know that packages are loaded only if one of its modules is loaded. If multiple packages are loaded into the same Language Server session, the cached interface files reflect that fact. This does not cause any problem in the same session, but if it is restarted and a single package loaded, the cache files still try to refer to the package that is not currently loaded. This leads to the whole session not being able to be loaded correctly and then displaying a sea of red squiggly lines until the previous session state is restored, e.g. other packages are loaded into the IDE.</p>
<p>This is obviously not the desired behaviour and, luckily, the fix was rather simple: We needed to isolate the cached interface files based on the packages that were currently loaded! This means that we maintain a set of cached interface files for every subset of loaded local packages. To illustrate this, imagine you have three packages A, B and C. The package A depends on B and C. When we load only the package A, we cache interface files so that subsequent loads of the package are faster. When we additionally load the package B, we cache interface files for B and new interface files for A. If we now load C, we have to re-cache the interface files again for A and B and generate new ones for C. In total, we now have three different sets of cache files for A, two for B and one for C. Overall, six sets of cached interface files have been created. When restarting the session and only opening the package A we will now use interface files for A for which no other package has been loaded. This is arguably a bit inefficient, but we expect to be able to reduce the number of cached interface files in the future.</p>
<p>We fixed the described bug at the cost of using more storage for cached interface files.</p>
<h2 id="the-sunset-of-haskell-ide-engine">The sunset of Haskell IDE Engine</h2>
<p>In this section I am going to briefly explain some of the terminology which is often used in the IDE context.</p>
<ul>
<li>Component: A component is a set of modules that form a single unit of code. For example, the library of a project is a component, the test-suite is a component and the executable is one as well.</li>
<li>Package: A package may consist of multiple components. It usually can be described using a single <code>.cabal</code> file.</li>
<li>Packages in GHC: packages in GHC resemble components, seeing as they are a set of modules that can be compiled with given options.</li>
</ul>
<p>As you may know, you can open a single component with <code>cabal</code> in a ghci session, via <code>cabal repl</code>. However, when you load an executable component which depends on the library component and make any changes to this component, you have to restart the whole session in order for your changes to take effect. This is rather inconvenient for local development but it turns out that Haskell IDE Engine works rather similarly. It loads a single component, which it can update just fine, but if you try to load a second one, a separate session (in a so-called <code>HscEnv</code>) is created which is separated from the first component. Thus, you may modify each component individually, but updates from one component will not be reflected on the other one until the whole Server is restarted. This is a major flaw in Haskell IDE Engine, one that is almost impossible to fix with the current structure. It would require to copy substantial parts of GHC into Haskell IDE Engine, and heavily modify them in order to implement this somewhat basic feature of updating the executable when the library is changed. In the end, this flaw sealed the fate of Haskell IDE Engine. Out of the ashes, ghcide rose, integrating some parts of GHC, such as parsing and typechecking a module and gaining better control and performance.</p>
<p>However, at the time of this writing, mainline ghcide does not support loading multiple components at the same time. So, was everything for nothing and Haskell IDEs will never get their happy ending? Not at all! It is merely not merged yet! Haskell Language Server provides support for loading multiple components at once by using a fork of <a href="https://github.com/mpickering/ghcide">ghcide</a> created by Matthew Pickering (@mpickering). Therefore, we can continue on our quest, implementing feature after feature until Haskell Language Server is a full-blown, highly-performant, reliable IDE? Unfortunately, there is still a catch to this story.</p>
<h2 id="reliable-multi-component-support">Reliable Multi Component Support</h2>
<p>The current implementation of multiple component support is somewhat… hacky. In the previous section, we described how Haskell IDE Engine supports loading multiple components and how this is lacking for a modern IDE. In Haskell Language Server, we are essentially tricking the compiler into thinking that all these components, libraries, executables and so on, are part of the same GHC package, each with a different set of compilation options. While this works fairly well in practice, it is complex and error-prone code. It is also a lot of work to maintain in the Language Server, e.g. supporting multiple GHC versions, keeping it performant, not introducing nasty bugs with new changes and adding new features, such as supporting <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/backpack">backpack</a>.</p>
<p>This is where my Google Summer Of Code project comes into play: this multiple component support ought to be taken care of by GHC itself! The Language Server should not be responsible of maintaining this chunk of code. Technically, the aim is to support multiple home packages in GHC and my work will be based on <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/935">existing efforts</a> of John Ericson (@Ericson2314) who is going to mentor me in this project, alongside Matthew Pickering and Zubin Duggal. If this project succeeds, not only will it be easier for IDEs to support multiple components in general, there is also direct benefit for the whole community! The issue that you can only load a single component into the same <code>ghci</code> session without resorting to complex tricks will be solved by this too. Not only will this improve usability of <code>ghci</code> for every user, different tools such as <code>ghcid</code> could be updated as well.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>2020-05-08-state-of-haskell-ide</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-08-state-of-haskell-ide.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-08-state-of-haskell-ide.html</id>
    <published>2020-05-08T00:00:00Z</published>
    <updated>2020-05-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> The State of Haskell IDEs </h2>
<p class="text-muted">
    Posted on May  8, 2020 by <a href="https://github.com/bubba">Luke Lau</a>
    <span class="avatar"><img src="/ide/images/bubba.png"/></span>
</p>

<p>It is an exciting time for Haskell tooling. As many might be aware, the past year has seen a number of significant changes to the ecosystem, with one of the most noticeable ones being <a href="https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html">the marriage of ghcide and haskell-ide-engine</a>. We now have contributors from both projects working towards a unified vision of a language server, the <em>haskell-language-server</em>, which aims to be the de-facto IDE for veteran and newcomer Haskellers alike: A full-fledged LSP server that provides diagnostics, code completion, navigation and more, works with both your Cabal and Stack projects, and scales from tiny scripts all the way up to huge codebases like GHC.</p>
<p><em>haskell-language-server</em> does not do this on its own however. It builds upon a whole ecosystem of tools to drive all of the underlying IDE features. How they all interconnect can be a bit overwhelming at first, so this post will break it down and take a look at them individually.</p>
<p align="center">
<img src="/ide/images/tooling-graph.png" alt="An overview of the current ecosystem" width="400" />
</p>
<!--more-->
<h3 id="ghcide">ghcide</h3>
<p>Powering the language server under the hood is <a href="https://github.com/digital-asset/ghcide">ghcide</a>. Based on tooling built for DAML, it is the core piece of infrastructure that talks to GHC to parse and typecheck your code. One of its many clever innovations is the use of the Shake build system to keep an in-memory cache of modules, file contents and other computations (e.g. code completions). Tooling built on top of it can then query it to get responsive, up-to-date information about the code it is working with. ghcide is also a language server itself, so if you need a lightweight IDE without any fancy trimmings then it will slot right in with any LSP client.</p>
<h3 id="hie-bios">hie-bios</h3>
<p>In order for ghcide to set up the GHC session, it needs to know what set of flags to pass to it. Unfortunately, this is not just as simple as <code>-Wall -O1</code> — if you ever run <code>cabal build -v</code> you will find that there are loads of flags passed to GHC, a lot of them related to whatever packages your project depends on. <a href="https://github.com/mpickering/hie-bios">hie-bios</a> takes care of this by querying the underlying build tool, such as Stack, Cabal or Hadrian, delegating it the work of figuring out the flags and building any package dependencies that might be needed. By specifying a <code>hie.yaml</code> file in your project’s root directory, you can specify one or more <em>cradles</em>, where each cradle represents some component to build with a specific build tool.</p>
<h3 id="cabal-helper">cabal-helper</h3>
<p>You can leave out the <code>hie.yaml</code> file, and hie-bios will try its best to infer which components to build with which tools. However this can get fairly complicated and hairy quickly. haskell-ide-engine and haskell-language-server use <a href="https://github.com/DanielG/cabal-helper.git">cabal-helper</a> to query more information about your project to help with this.</p>
<h3 id="haskell-lsp">haskell-lsp</h3>
<p><a href="https://github.com/alanz/haskell-lsp">haskell-lsp</a> provides the transport between the client and the server using the Language Server Protocol. It keeps track of a lot of bookkeeping within the protocol, like request IDs and client/server capabilities, and also provides a virtual file system that mirrors edits coming in from the text editor, before they have saved the actually document. Having this mirror is pretty useful for external tools that need to be run on physical files rather than in-memory text buffers. Its sister library, haskell-lsp-types, provides type definitions for the actual specification, so if you want to do your own thing you don’t need to rewrite the data types and parsing all over again.</p>
<h3 id="lsp-test">lsp-test</h3>
<p><a href="https://github.com/bubba/lsp-test">lsp-test</a> is a testing framework for LSP servers, used by ghcide, HIE and haskell-language-server. It acts as a language client that can be programmed to send messages to servers, and assert that the right messages are received back. It can also be used to recreate certain scenarios: <a href="https://lukelau.me/haskell/posts/leak/">useful for hunting down memory leaks</a>.</p>
<h3 id="ghc-.hie-files">GHC <code>.hie</code> files</h3>
<p>A lot of the work on ghcide and haskell-ide-engine has driven new features and functionality upstream into GHC. One such example is <a href="https://www.haskell.org/ghc/blog/20190626-HIEFiles.html"><code>.hie</code> files</a>. These are generated with the <code>-fwrite-ide-flag</code> during compilation, and like a <code>.hi</code> file they contain additional information about some compiled module. However <code>.hie</code> files contain lots of information specifically useful for tooling, such as the type of expressions or where things are defined, hence the acronym for <em>haskell information extended</em> — not to be confused with haskell-ide-engine! Work is underway to use these files in ghcide to provide much more accurate code navigation, completion and type definitions.</p>
<h3 id="haskell-ide-engine">haskell-ide-engine</h3>
<p>The <a href="https://github.com/haskell/haskell-ide-engine">haskell-ide-engine</a> is a language server that faithfully served as a focal point for a whole suite of tools. It’s been a relatively long-running project: It predates the existence of LSP! It originally used ghc-mod as its backend before switching to hie-bios, and it provides a bunch of logic for extracting code completion and symbols etc. out of the GHC API that eventually got absorbed into ghcide. It also has a plugin system which allows external tools to easily interface with LSP. So built into HIE, Floskell, Ormolu and Brittany can provide formatting whilst GHC, Liquid Haskell and HLint provide diagnostics, all through the same interface.</p>
<h3 id="haskell-language-server">haskell-language-server</h3>
<p><a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a> now aims to concentrate the efforts behind ghcide and haskell-ide-engine. It uses the powerful core of ghcide and HIE’s approach of plugins to integrate an ecosystem worth of tools. Eventually there will be enough tools integrated that users will be able to configure what tools they want to use for each job. Floskell for formatting, or Ormolu? And more importantly, because it builds upon so many components, haskell-language-server will receive any improvements made downstream. This division of labour allows contributors to focus on the individual problems that need tackled, whilst benefiting the whole ecosystem.</p>
<p>Ultimately this means that <strong>haskell-ide-engine is being sunset and users should eventually move to haskell-language-server</strong> when it is ready. <strong>ghcide will continue to be developed</strong> and will serve as the underlying backend that powers haskell-language-server.</p>
<h3 id="looking-forward">Looking forward</h3>
<p>We are now entering the <em>renaissance</em> of Haskell tooling. This summer there are 3 Google Summer of Code projects and a Tweag open source fellowship all working on tooling, as well as the continued efforts of many contributors.</p>
<p><a href="https://github.com/fendor">Fendor</a> is working on supporting compilation of multiple <em>home-packages</em> at once within GHC. In short this will allow tooling to work with multiple components inside a package simultaneously. <a href="http://github.com/bubba">Luke Lau</a> (that’s me) is improving the implicit discovery of cradles in hie-bios by connecting together the <a href="https://github.com/haskell/cabal/pull/6241">Cabal <code>show-build-info</code> command</a>, which will give a much more reliable Cabal setup in the absence of <code>hie.yaml</code> files. <a href="http://github.com/wz1000">Zubin Duggal</a> will be focusing on the haskell-language-server, fleshing out its features and taking advantage of GHC’s <code>.hie</code> files. And <a href="https://github.com/mpardalos">Michalis Pardalos</a> is integrating <a href="https://opentelemetry.io">OpenTelemetry</a> with the language servers, so that we can instrument and profile how they perform on the vast heterogeneous array of LSP clients that they may be used with.</p>
<p>By the end of the summer we will have built a robust language server which works on any Haskell project of any size and built with any build system.</p>
<p>There are a lot of exciting projects in the pipeline, and we will be posting about them here every Friday. In the meantime, come chat with us over at <a href="irc://irc.freenode.net/haskell-ide-engine">#haskell-ide-engine</a> on Freenode, clone some projects and help us build the ultimate Haskell IDE.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>

</feed>
