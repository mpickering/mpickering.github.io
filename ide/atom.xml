<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>IDE 2020 Updates</title>
    <link href="http://mpickering.github.io//ide/atom.xml" rel="self" />
    <link href="http://mpickering.github.io/" />
    <id>http://mpickering.github.io//ide/atom.xml</id>
    <author>
        <name>Matthew Pickering</name>
        <email>matthewtpickering@gmail.com</email>
    </author>
    <updated>2020-05-22T00:00:00Z</updated>
    <entry>
    <title>Adding tracing to ghcide</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-22-tracing-plan.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-22-tracing-plan.html</id>
    <published>2020-05-22T00:00:00Z</published>
    <updated>2020-05-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Adding tracing to ghcide </h2>
<p class="text-muted">
    Posted on May 22, 2020 by <a href="https://github.com/mpardalos">Michalis Pedalos</a>
    <span class="avatar"><img src="/ide/images/mpardalos.png"/></span>
</p>

<p>Welcome to the third post on the ongoing work on a unified Haskell IDE. This week I will be talking about my Google Summer of Code project to <em>introduce tracing into ghcide</em> using OpenTelemetry. I will explain the motivation for this project and then explain what it actually entails, as well as what improvements you should expect to see as a result of it.</p>
<h1 id="what-is-the-problem">What is the problem?</h1>
<p>The internal architecture of ghcide is based on the <a href="https://shakebuild.com">Shake</a> build system. This is a tool similar in principle to UNIX make, except implemented as a Haskell library. While using a build tool as the core of an IDE might be surprising, it simplifies the internals of the engine, and allows for reuse of information. This is a big contributor to ghcide’s speed. A more detailed explanation is given <a href="https://4ta.uk/p/shaking-up-the-ide">here</a>.</p>
<p>It’s not all rosy though. In order for shake to provide these benefits, it must entirely (with some caveats) control the execution of the IDE engine. Shake loads/parses/typechecks files whenever it sees fit, based on which files have changed and what is requested by the editor. This means that reasoning about performance becomes much harder. It’s hard to tell what action is slow when you don’t know or directly control which ones are running.</p>
<h1 id="so-what-are-you-doing-about-it">So what are you doing about it?</h1>
<p>Addressing this problem is the core of my Google Summer of Code project: I will be introducing tracing to ghcide. This essentially amounts to wrapping interesting sections of code in <code>print &quot;begin &lt;section&gt;</code> and <code>print &quot;end &lt;section&quot;</code>, albeit in a slightly more sophisticated way. This will allow us to track which sections are running at any given time and for how long. I will be doing this using <a href="https://opentelemetry.io/">opentelemetry</a> and Dmitry Ivanov’s (@ethercrow) <code>haskell-opentelemetry</code> library, allowing for better tooling support over simple console logging.</p>
<p>OpenTelemetry is a set of tools and APIs for monitoring applications in a variety of ways. We will be using its tracing portion which will allow us to view traces from ghcide in any opentelemetry-compatible viewer, like <a href="https://jaegertracing.io/">Jaeger</a> or chrome’s <code>about:tracing</code>. So, to address some confusion from the reddit comments on last week’s post, this has nothing to do with telemetry, as used in e.g. Visual Studio Code or Windows. It is explicitly opt-in and does not transmit any data over the network.</p>
<p>Matthew Pickering (@mpickering) has already started this effort. He has added initial support for tracing allowing us to get some basic traces. What I will be adding is more detail. The way shake works is that you issue <em>Actions</em> to be run, which can then request data, which based on some rules is calculated using other Actions, etc. We can currently only trace the initial actions, not any of their dependencies. For example, we know can see how long going to definition takes in its entirety, but not how much of that time was spent loading or parsing files. Adding this will give us a complete picture of what ghcide is doing.</p>
<h1 id="thats-great-and-all-but-what-do-i-get">That’s great and all, but what do I get?</h1>
<p>Great question! Indeed, this is a developer-facing feature. We are not expecting users of ghcide to be looking at traces. We are hoping however it will guide us towards a faster ghcide by showing us what parts are worth improving. It should also make locating certain classes of bugs easier by showing us if Shake is doing what we are expecting it to.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>Weekly Update and Multiple Components</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-15-multiple-components.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-15-multiple-components.html</id>
    <published>2020-05-15T00:00:00Z</published>
    <updated>2020-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> Weekly Update and Multiple Components </h2>
<p class="text-muted">
    Posted on May 15, 2020 by <a href="https://github.com/fendor">Fendor</a>
    <span class="avatar"><img src="/ide/images/fendor.png"/></span>
</p>

<p>This is the second blog post in this year’s series of IDE blog posts. In this blog post I will first present the progress we made during the last week, what we have been working on, what has been implemented, and what has been fixed. In the second section I will give some insights on why Haskell IDE Engine is in the retirement process. It explains the shortcomings of its structure and why ghcide supersedes it. In the last section, I will explain the motivation for implementing multiple home packages for GHC and how it, hopefully, will benefit IDEs and every-day users of GHC.</p>
<p><a href="https://gifyu.com/image/nkjS"><img src="https://s6.gifyu.com/images/JumpToInstance.gif" alt="Jump To Instance Definition" /></a></p>
<!--more-->
<h2 id="this-week">This week</h2>
<p>A week has passed since the introduction to the state of IDEs in Haskell. A lot has happened in this one week and I am here to tell you about a few things in detail!</p>
<h3 id="support-for-ghc-8.10.1">Support for GHC 8.10.1</h3>
<p>Maintaining an IDE is a lot of work and we couldn’t do it without the work of volunteers. Part of the maintenance work is updating dependencies and fixing any errors that might occur! This week, as during countless weeks before that, Javier Neira (@jneira) took care of a lot of maintenance work such as responding to issues, fixing bugs and updating Haskell Language Server to be compatible with GHC 8.10.1! Updating Haskell Language Server to support a new GHC version is a huge effort, as it has plenty of dependencies and all of these need to be updated in order to support the newer version.</p>
<h3 id="references">References</h3>
<p><strong>Disclaimer</strong> This feature hasn’t been merged, yet, due to issues with older GHC versions.</p>
<p>Modern IDEs need to be capable of showing you all references to a function, where it is implemented and intelligent code search in general. It should not be necessary to query the function name throughout the whole project to find the implementation. While code-actions such as “Go to Definition” and “Go to Type Definition” have been working for some time now, searching for all references of an identifier has not been implemented as of yet.</p>
<p>But this is bound to change soon! Zubin Duggal developed a working implementation of finding references in a project based on <a href="https://github.com/wz1000/hiedb">hiedb</a>. <code>hiedb</code> is powered by <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/hie-files">HIE</a> files, which are basically very verbose compiler artefacts that can be used to query references, the type of an expression, and a lot of other things (see projects such as <a href="https://hackage.haskell.org/package/weeder">weeder</a>).</p>
<p>Below is a working example of how these HIE files can be used:</p>
<p><a href="https://gifyu.com/image/nkzg"><img src="https://s6.gifyu.com/images/References.gif" alt="Find References" style="width:100.0%" /></a></p>
<p>It allows developers to look for all usages of a function or type and to see all usages of a parameter or definition within a function!</p>
<h3 id="jump-to-instance-definition">Jump to Instance Definition</h3>
<p><strong>Disclaimer</strong> This feature is not yet merged into GHC, but will probably ship with GHC 8.12.</p>
<p>It is well known that you can jump to function definitions in Haddock. For functions that are part of a type-class, you jump to the type-class declaration. However, that is usually not what you want. Thus, Zubin Duggal has implemented a new feature that will allow you to jump to the specific instance definition used by an overloaded function.</p>
<p><a href="https://gifyu.com/image/nkjS"><img src="https://s6.gifyu.com/images/JumpToInstance.gif" alt="Jump To Instance Definition" /></a></p>
<p>This is a really useful feature and will make it easier to explore a code base! Moreover, it can make the IDE experience smoother for developers. LSP supports returning multiple locations for go-to definition requests which we could exploit to give the user a choice about where to jump to.</p>
<h3 id="first-step-towards-open-telemetry-support">First step towards <code>Open Telemetry</code> support</h3>
<p>We are happy to announce that the first <a href="https://github.com/mpickering/ghcide/pull/26">Pull Request</a> of Michalis (@mpardalos) has been merged to Haskell Language Server!</p>
<p>It is a small step compared to the big task ahead to provide telemetry data of IDEs such as the Haskell Language Server. The final goal is to gain insight into the performance of big projects and optimising bottlenecks. To accomplish this, <a href="https://opentelemetry.io/">Open Telemetry</a> will be used to emit relevant performance information. Very recently, the <a href="https://hackage.haskell.org/package/opentelemetry">opentelemetry</a> package was added to Hackage by Dmitry Ivanov (@ethercrow) which will aid the task.</p>
<h3 id="memorable-bug-fixes">Memorable Bug-Fixes</h3>
<p>I will now highlight some of the most memorable bugs we fixed this week, when working on the Haskell Language Server.</p>
<h4 id="completions">Completions</h4>
<p>Since the last blog post, we were informed that there were no completions being provided by the Haskell Language Server, although there are completions when using ghcide. What happened here? Why did Haskell Language Server not use the completion system of ghcide?</p>
<p>The answer was, the completion plugin had not been enabled. Thank you @korayal for providing the <a href="https://github.com/haskell/haskell-language-server/pull/107">fix</a> to this issue!</p>
<p>As an interesting side-note, the completion system of ghcide is almost the same as the one from Haskell IDE Engine! It was ported to ghcide (with some tweaks) and now found its way back into Haskell Language Server.</p>
<h4 id="bad-interface-files">Bad Interface Files</h4>
<p>A particularly nasty bug occured when cached interface files were out of sync. The details of how a project is loaded are described later, but for now it suffices to know that packages are loaded only if one of its modules is loaded. If multiple packages are loaded into the same Language Server session, the cached interface files reflect that fact. This does not cause any problem in the same session, but if it is restarted and a single package loaded, the cache files still try to refer to the package that is not currently loaded. This leads to the whole session not being able to be loaded correctly and then displaying a sea of red squiggly lines until the previous session state is restored, e.g. other packages are loaded into the IDE.</p>
<p>This is obviously not the desired behaviour and, luckily, the fix was rather simple: We needed to isolate the cached interface files based on the packages that were currently loaded! This means that we maintain a set of cached interface files for every subset of loaded local packages. To illustrate this, imagine you have three packages A, B and C. The package A depends on B and C. When we load only the package A, we cache interface files so that subsequent loads of the package are faster. When we additionally load the package B, we cache interface files for B and new interface files for A. If we now load C, we have to re-cache the interface files again for A and B and generate new ones for C. In total, we now have three different sets of cache files for A, two for B and one for C. Overall, six sets of cached interface files have been created. When restarting the session and only opening the package A we will now use interface files for A for which no other package has been loaded. This is arguably a bit inefficient, but we expect to be able to reduce the number of cached interface files in the future.</p>
<p>We fixed the described bug at the cost of using more storage for cached interface files.</p>
<h2 id="the-sunset-of-haskell-ide-engine">The sunset of Haskell IDE Engine</h2>
<p>In this section I am going to briefly explain some of the terminology which is often used in the IDE context.</p>
<ul>
<li>Component: A component is a set of modules that form a single unit of code. For example, the library of a project is a component, the test-suite is a component and the executable is one as well.</li>
<li>Package: A package may consist of multiple components. It usually can be described using a single <code>.cabal</code> file.</li>
<li>Packages in GHC: packages in GHC resemble components, seeing as they are a set of modules that can be compiled with given options.</li>
</ul>
<p>As you may know, you can open a single component with <code>cabal</code> in a ghci session, via <code>cabal repl</code>. However, when you load an executable component which depends on the library component and make any changes to this component, you have to restart the whole session in order for your changes to take effect. This is rather inconvenient for local development but it turns out that Haskell IDE Engine works rather similarly. It loads a single component, which it can update just fine, but if you try to load a second one, a separate session (in a so-called <code>HscEnv</code>) is created which is separated from the first component. Thus, you may modify each component individually, but updates from one component will not be reflected on the other one until the whole Server is restarted. This is a major flaw in Haskell IDE Engine, one that is almost impossible to fix with the current structure. It would require to copy substantial parts of GHC into Haskell IDE Engine, and heavily modify them in order to implement this somewhat basic feature of updating the executable when the library is changed. In the end, this flaw sealed the fate of Haskell IDE Engine. Out of the ashes, ghcide rose, integrating some parts of GHC, such as parsing and typechecking a module and gaining better control and performance.</p>
<p>However, at the time of this writing, mainline ghcide does not support loading multiple components at the same time. So, was everything for nothing and Haskell IDEs will never get their happy ending? Not at all! It is merely not merged yet! Haskell Language Server provides support for loading multiple components at once by using a fork of <a href="https://github.com/mpickering/ghcide">ghcide</a> created by Matthew Pickering (@mpickering). Therefore, we can continue on our quest, implementing feature after feature until Haskell Language Server is a full-blown, highly-performant, reliable IDE? Unfortunately, there is still a catch to this story.</p>
<h2 id="reliable-multi-component-support">Reliable Multi Component Support</h2>
<p>The current implementation of multiple component support is somewhat… hacky. In the previous section, we described how Haskell IDE Engine supports loading multiple components and how this is lacking for a modern IDE. In Haskell Language Server, we are essentially tricking the compiler into thinking that all these components, libraries, executables and so on, are part of the same GHC package, each with a different set of compilation options. While this works fairly well in practice, it is complex and error-prone code. It is also a lot of work to maintain in the Language Server, e.g. supporting multiple GHC versions, keeping it performant, not introducing nasty bugs with new changes and adding new features, such as supporting <a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/backpack">backpack</a>.</p>
<p>This is where my Google Summer Of Code project comes into play: this multiple component support ought to be taken care of by GHC itself! The Language Server should not be responsible of maintaining this chunk of code. Technically, the aim is to support multiple home packages in GHC and my work will be based on <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/935">existing efforts</a> of John Ericson (@Ericson2314) who is going to mentor me in this project, alongside Matthew Pickering and Zubin Duggal. If this project succeeds, not only will it be easier for IDEs to support multiple components in general, there is also direct benefit for the whole community! The issue that you can only load a single component into the same <code>ghci</code> session without resorting to complex tricks will be solved by this too. Not only will this improve usability of <code>ghci</code> for every user, different tools such as <code>ghcid</code> could be updated as well.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>
<entry>
    <title>The State of Haskell IDEs</title>
    <link href="http://mpickering.github.io//ide/posts/2020-05-08-state-of-haskell-ide.html" />
    <id>http://mpickering.github.io//ide/posts/2020-05-08-state-of-haskell-ide.html</id>
    <published>2020-05-08T00:00:00Z</published>
    <updated>2020-05-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2> The State of Haskell IDEs </h2>
<p class="text-muted">
    Posted on May  8, 2020 by <a href="https://github.com/bubba">Luke Lau</a>
    <span class="avatar"><img src="/ide/images/bubba.png"/></span>
</p>

<p>It is an exciting time for Haskell tooling. As many might be aware, the past year has seen a number of significant changes to the ecosystem, with one of the most noticeable ones being <a href="https://neilmitchell.blogspot.com/2020/01/one-haskell-ide-to-rule-them-all.html">the marriage of ghcide and haskell-ide-engine</a>. We now have contributors from both projects working towards a unified vision of a language server, the <em>haskell-language-server</em>, which aims to be the de-facto IDE for veteran and newcomer Haskellers alike: A full-fledged LSP server that provides diagnostics, code completion, navigation and more, works with both your Cabal and Stack projects, and scales from tiny scripts all the way up to huge codebases like GHC.</p>
<p><em>haskell-language-server</em> does not do this on its own however. It builds upon a whole ecosystem of tools to drive all of the underlying IDE features. How they all interconnect can be a bit overwhelming at first, so this post will break it down and take a look at them individually.</p>
<p align="center">
<img src="/ide/images/tooling-graph.png" alt="An overview of the current ecosystem" width="400" />
</p>
<!--more-->
<h3 id="ghcide">ghcide</h3>
<p>Powering the language server under the hood is <a href="https://github.com/digital-asset/ghcide">ghcide</a>. Based on tooling built for DAML, it is the core piece of infrastructure that talks to GHC to parse and typecheck your code. One of its many clever innovations is the use of the Shake build system to keep an in-memory cache of modules, file contents and other computations (e.g. code completions). Tooling built on top of it can then query it to get responsive, up-to-date information about the code it is working with. ghcide is also a language server itself, so if you need a lightweight IDE without any fancy trimmings then it will slot right in with any LSP client.</p>
<h3 id="hie-bios">hie-bios</h3>
<p>In order for ghcide to set up the GHC session, it needs to know what set of flags to pass to it. Unfortunately, this is not just as simple as <code>-Wall -O1</code> — if you ever run <code>cabal build -v</code> you will find that there are loads of flags passed to GHC, a lot of them related to whatever packages your project depends on. <a href="https://github.com/mpickering/hie-bios">hie-bios</a> takes care of this by querying the underlying build tool, such as Stack, Cabal or Hadrian, delegating it the work of figuring out the flags and building any package dependencies that might be needed. By specifying a <code>hie.yaml</code> file in your project’s root directory, you can specify one or more <em>cradles</em>, where each cradle represents some component to build with a specific build tool.</p>
<h3 id="cabal-helper">cabal-helper</h3>
<p>You can leave out the <code>hie.yaml</code> file, and hie-bios will try its best to infer which components to build with which tools. However this can get fairly complicated and hairy quickly. haskell-ide-engine and haskell-language-server use <a href="https://github.com/DanielG/cabal-helper.git">cabal-helper</a> to query more information about your project to help with this.</p>
<h3 id="haskell-lsp">haskell-lsp</h3>
<p><a href="https://github.com/alanz/haskell-lsp">haskell-lsp</a> provides the transport between the client and the server using the Language Server Protocol. It keeps track of a lot of bookkeeping within the protocol, like request IDs and client/server capabilities, and also provides a virtual file system that mirrors edits coming in from the text editor, before they have saved the actually document. Having this mirror is pretty useful for external tools that need to be run on physical files rather than in-memory text buffers. Its sister library, haskell-lsp-types, provides type definitions for the actual specification, so if you want to do your own thing you don’t need to rewrite the data types and parsing all over again.</p>
<h3 id="lsp-test">lsp-test</h3>
<p><a href="https://github.com/bubba/lsp-test">lsp-test</a> is a testing framework for LSP servers, used by ghcide, HIE and haskell-language-server. It acts as a language client that can be programmed to send messages to servers, and assert that the right messages are received back. It can also be used to recreate certain scenarios: <a href="https://lukelau.me/haskell/posts/leak/">useful for hunting down memory leaks</a>.</p>
<h3 id="ghc-.hie-files">GHC <code>.hie</code> files</h3>
<p>A lot of the work on ghcide and haskell-ide-engine has driven new features and functionality upstream into GHC. One such example is <a href="https://www.haskell.org/ghc/blog/20190626-HIEFiles.html"><code>.hie</code> files</a>. These are generated with the <code>-fwrite-ide-flag</code> during compilation, and like a <code>.hi</code> file they contain additional information about some compiled module. However <code>.hie</code> files contain lots of information specifically useful for tooling, such as the type of expressions or where things are defined, hence the acronym for <em>haskell information extended</em> — not to be confused with haskell-ide-engine! Work is underway to use these files in ghcide to provide much more accurate code navigation, completion and type definitions.</p>
<h3 id="haskell-ide-engine">haskell-ide-engine</h3>
<p>The <a href="https://github.com/haskell/haskell-ide-engine">haskell-ide-engine</a> is a language server that faithfully served as a focal point for a whole suite of tools. It’s been a relatively long-running project: It predates the existence of LSP! It originally used ghc-mod as its backend before switching to hie-bios, and it provides a bunch of logic for extracting code completion and symbols etc. out of the GHC API that eventually got absorbed into ghcide. It also has a plugin system which allows external tools to easily interface with LSP. So built into HIE, Floskell, Ormolu and Brittany can provide formatting whilst GHC, Liquid Haskell and HLint provide diagnostics, all through the same interface.</p>
<h3 id="haskell-language-server">haskell-language-server</h3>
<p><a href="https://github.com/haskell/haskell-language-server">haskell-language-server</a> now aims to concentrate the efforts behind ghcide and haskell-ide-engine. It uses the powerful core of ghcide and HIE’s approach of plugins to integrate an ecosystem worth of tools. Eventually there will be enough tools integrated that users will be able to configure what tools they want to use for each job. Floskell for formatting, or Ormolu? And more importantly, because it builds upon so many components, haskell-language-server will receive any improvements made downstream. This division of labour allows contributors to focus on the individual problems that need tackled, whilst benefiting the whole ecosystem.</p>
<p>Ultimately this means that <strong>haskell-ide-engine is being sunset and users should eventually move to haskell-language-server</strong> when it is ready. <strong>ghcide will continue to be developed</strong> and will serve as the underlying backend that powers haskell-language-server.</p>
<h3 id="looking-forward">Looking forward</h3>
<p>We are now entering the <em>renaissance</em> of Haskell tooling. This summer there are 3 Google Summer of Code projects and a Tweag open source fellowship all working on tooling, as well as the continued efforts of many contributors.</p>
<p><a href="https://github.com/fendor">Fendor</a> is working on supporting compilation of multiple <em>home-packages</em> at once within GHC. In short this will allow tooling to work with multiple components inside a package simultaneously. <a href="http://github.com/bubba">Luke Lau</a> (that’s me) is improving the implicit discovery of cradles in hie-bios by connecting together the <a href="https://github.com/haskell/cabal/pull/6241">Cabal <code>show-build-info</code> command</a>, which will give a much more reliable Cabal setup in the absence of <code>hie.yaml</code> files. <a href="http://github.com/wz1000">Zubin Duggal</a> will be focusing on the haskell-language-server, fleshing out its features and taking advantage of GHC’s <code>.hie</code> files. And <a href="https://github.com/mpardalos">Michalis Pardalos</a> is integrating <a href="https://opentelemetry.io">OpenTelemetry</a> with the language servers, so that we can instrument and profile how they perform on the vast heterogeneous array of LSP clients that they may be used with.</p>
<p>By the end of the summer we will have built a robust language server which works on any Haskell project of any size and built with any build system.</p>
<p>There are a lot of exciting projects in the pipeline, and we will be posting about them here every Friday. In the meantime, come chat with us over at <a href="irc://irc.freenode.net/haskell-ide-engine">#haskell-ide-engine</a> on Freenode, clone some projects and help us build the ultimate Haskell IDE.</p>

<hr>
<a class="text-muted" href="/ide/index.html">Index</a>
]]></summary>
</entry>

</feed>
